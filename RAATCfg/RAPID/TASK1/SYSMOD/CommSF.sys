MODULE CommSF(SYSMODULE,NOVIEW)
!*******************************************************************
! Interface with ASFM software module from Servo-Robot 
!(Ethernet TCP/IP based on RCL APP protocol - Reduced version)
!   
! Requirements    Requires the PC Interface option from ABB (616-1)
!                 AutoCal2.sys must be loaded on robot
! Prefix:         ASFM
! Version:        ABB190702.002 (based on Rel151001.110 on vision system)
! Date:           October 16th 2019
! Author:         Servo-Robot (Cedric Demers-Roy)
! Copyright:      Servo-Robot Inc. 2019
!
! NOTE:  Function with ASFMu_ prefix are to be used in user programs
!*******************************************************************

!corrdata type is used as output for ASFM measurement functions
RECORD corrdata
    num i;      !Index of this correction data
    num Status; !-1=not initialized; 1=reference acquired; 2=current data acquired; 3=correction data computed
    num tx;
    num ty;
    num tz;
    num oa;
    num ob;
    num oc;
    num ar;
    num gp;
    num ms;
 ENDRECORD
 
 RECORD corrdata3
    num i;      !Index of this correction data
    num Status; !-1=not initialized; 1=reference acquired; 2=current data acquired; 3=correction data computed
    num tx;
    num ty;
    num tz;
    num oa;
    num ob;
    num oc;
    num ar;
    num gp;
    num ms;
    num Status2;
    num tx2;
    num ty2;
    num tz2;
    num oa2;
    num ob2;
    num oc2;
    num ar2;
    num gp2;
    num ms2;
    num Status3;
    num tx3;
    num ty3;
    num tz3;
    num oa3;
    num ob3;
    num oc3;
    num ar3;
    num gp3;
    num ms3;
 ENDRECORD
!---****DO NOT MODIFY VARIABLES BELOW THIS LINE****---
LOCAL VAR clock ComASFMTime;
TASK PERS num ASFM_InspNumber:=1393;
VAR string ASFM_IP_Add:="192.168.2.3"; !Must match the IP address of the vision system (ROBOT port; not USER)
VAR num ASFM_IP_Port:=6344; !Always 6344 to use RCL APP protocol
VAR num ASFM_M_Lvl:=0;!0=No message; 1=Error messages; 2=Add Correction messages; 3=Add intermediate messages; 4=Add commands and replies
VAR string stASFMReceived;
VAR socketdev ComASFMSocket;
PERS tooldata MyToolASFM:=[TRUE,[[-76.79,-1.749,591.944],[0.981627,0,0.190809,0]],[3,[0,0,1],[1,0,0,0],0,0,0]]; !Defined by ASFMu_Initialize() function
PERS wobjdata MyWobjASFM:=[FALSE,TRUE,"",[[0,0,0],[1,0,0,0]],[[0,0,0],[1,0,0,0]]];     !Defined by ASFMu_Initialize() function
PERS num AlphaCal:=-1.46; !Store angle computed during calibration for check process
PERS num BetaCal:=-0.036; !Store angle computed during calibration for check process
PERS num GammaCal:=0.067; !Store angle computed during calibration for check process
TASK PERS tooldata NullToolASFM:=[TRUE,[[0,0,0],[1,0,0,0]],[3,[25,100,200],[1,0,0,0],0,0,0]];
!TASK PERS tooldata NullToolASFM:=[TRUE,[[-2.21843,-2.98935,353.532],[1,0,0,0]],[3,[25,100,200],[1,0,0,0],0,0,0]];
!TASK PERS tooldata NullToolASFM:=[TRUE,[[1.71252,-0.10988,316.778],[0.231942,0.64599,-0.701825,-0.190631]],[4,[50,50,100],[1,0,0,0],0,0,0]];
TASK PERS tooldata RefToolASFM:=[TRUE,[[-76.79,-1.749,591.944],[0.981627,0,0.190809,0]],[3,[0,0,1],[1,0,0,0],0,0,0]];
TASK PERS wobjdata NullWobjASFM:=[FALSE,TRUE,"",[[0,0,0],[1,0,0,0]],[[0,0,0],[1,0,0,0]]];
TASK PERS toolData ToolCalib:=[TRUE,[[31.248,14.0216,390.819],[0.421855,0.868576,-0.0416447,0.256669]],[3,[25,100,200],[1,0,0,0],0,0,0]];
!TASK PERS toolData ToolCamera:=[TRUE,[[56.003,-29.01,492.546],[0.316441,0.701585,-0.626259,-0.124271]],[3,[25,100,200],[1,0,0,0],0,0,0]];
TASK PERS toolData ToolCameraBackup:=[TRUE,[[127.716,-19.712,406.161],[0.348806,0.77922,-0.514589,0.0796804]],[3,[25,100,200],[1,0,0,0],0,0,0]];
TASK PERS toolData       ToolCamera:=[TRUE,[[-41.306,141.89,485.505],[0.410898,0.873811,-0.0377008,0.257286]],[3,[25,100,200],[1,0,0,0],0,0,0]];
TASK PERS toolData ToolCamera2:=[TRUE,[[56.6133,-28.2262,491.913],[0.316016,0.701546,-0.6264,-0.124862]],[3,[25,100,200],[1,0,0,0],0,0,0]];
TASK PERS robtarget StartCamPosCheck:=[[59.5001,54.0002,-0.000208616],[0.982839,-2.96093E-08,0.184466,-5.05609E-09],[-1,-4,1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
TASK PERS bool gUseFlangeCalib:=TRUE; !When TRUE, ASFM module uses FLANGE calibration (NullTool used for all measurements)
PERS pose TCam:=[[56.6133,-28.2262,491.913],[0.316016,0.701546,-0.6264,-0.124862]]; !This variable contains the calibration between laser-camera and robot flange (PERSISTENT)
VAR num ASFMLaserStatus; !1=ON; 2=OFF; 3=MUTED; 4=PENDING(3sec)
VAR num ASFMInspectionStatus; !-2=non initialized; -1=error; 0=failed; 1=no match; 2=warning; 3=good
VAR num ASFMSeqID;   !Contains the ID of the message in the sequence (up counter)
VAR iodev LogCalib;  !To save calibration results (when activated by ASFMu_Initialize() function)
VAR iodev LogMode0;  !To save ASFM measurements in Mode 0 (when activated by ASFMu_Initialize() function)
VAR iodev LogMode1;  !To save ASFM measurements in Mode 1 (when activated by ASFMu_Initialize() function)
VAR iodev LogMode3;  !To save ASFM measurements in Mode 3 (when activated by ASFMu_Initialize() function)
VAR iodev LogMode4;  !To save ASFM measurements in Mode 4 (when activated by ASFMu_Initialize() function)
VAR iodev LogMode5;  !To save ASFM measurements in Mode 5 (when activated by ASFMu_Initialize() function)
VAR iodev LogMode6;  !To save ASFM measurements in Mode 6 (when activated by ASFMu_Initialize() function)
VAR iodev LogMode8;  !To save ASFM measurements in Mode 8 (when activated by ASFMu_Initialize() function)
VAR iodev LogMode9;  !To save ASFM measurements in Mode 9 (when activated by ASFMu_Initialize() function)
VAR iodev LogMode11;  !To save ASFM measurements in Mode 11 (when activated by ASFMu_Initialize() function)
VAR iodev LogMode12;  !To save ASFM measurements in Mode 12 (when activated by ASFMu_Initialize() function)

VAR iodev LogASFMErrors; !To save ASFM errors in all modes including calibration (when activated by ASFMu_Initialize() function)
VAR bool ASFM_LogData;   !Defined by ASFMu_Initialize() function
VAR bool ASFM_LogErrors; !Defined by ASFMu_Initialize() function
!---****END OF VARIABLE DECLARATION SECTION****---

!Command to set the IP address and port for the communication with the vision system
PROC ASFM_SetCommunication(string IPAddr, num IPPort)
    ASFM_IP_Add:=IPAddr;
    ASFM_IP_Port:=IPPort;
ENDPROC

!Command to set the tool and base (wobj) used for all SF functions
!NOTE: tool is only used if gUseFlangeCalib is set to FALSE (NullToolASFM is used otherwise)
PROC ASFM_SetTool(tooldata SFTool, wobjdata SFWobj)
    MyToolASFM:=SFTool;
    MyWobjASFM:=SFWobj;
ENDPROC

!Command to set the tool and base (wobj) used for all SF functions
!NOTE: tool is only used if gUseFlangeCalib is set to FALSE (NullToolASFM is used otherwise)
PROC ASFM_SetRefTool(tooldata SFTool, wobjdata SFWobj)
    RefToolASFM:=SFTool;
    MyWobjASFM:=SFWobj;
ENDPROC

!Command to set the calibration type based on internal variable gUseFlangeCalib
!NOTE: gUseFlangeCalib is updated in the ASFMuInitialize() function call
FUNC bool ASFM_SetCalibrationType()
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num icorr;
    VAR num NbBytes;
    VAR bool dataok;
    VAR bool Fout;
    VAR num TypeCal;
    Fout:=FALSE;
    IF gUseFlangeCalib THEN
        TypeCal:=2;
    ELSE
        TypeCal:=1;
    ENDIF
    
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><sct v=""" + ValToStr(TypeCal) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot set parameter spa. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Set calibration type error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ELSE 
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Calibration type was set.";
        ENDIF
    ENDIF 
    Fout:=TRUE;
    RETURN Fout;    
ENDFUNC

!Command to set the messaging level of the functions in this interface
!0=No message
!1=Error messages only
!2=Add Correction messages (typical level when testing new programs)
!3=Add intermediate messages (only for troubleshooting)
!4=Higher messaging level (includes commands and replies in TXT format on TP)
PROC ASFM_SetMessagingLevel(num Level)
    ASFM_M_Lvl:=Level;
ENDPROC

!Special wait command which is based in msec instead of sec.
PROC ASFM_WaitTimeMs(num delay)
    var clock MyDelay;
    var num CurTime;
    CurTime:=0;
    ClkReset MyDelay;
    ClkStart MyDelay;
    WHILE CurTime < delay DO
        CurTime:=1000*ClkRead(MyDelay \HighRes);
    ENDWHILE
    ClkStop MyDelay;
ENDPROC

!Function which analyzes field r and e in a reply to check for error
!The variable stASFMReceived must be filled before function call (local persistent variable)
FUNC errdata ASFM_HasError(string datain)
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR bool DataOK;
    VAR errdata MyErrData;
    
    indexr:=StrMatch(datain,1,"r=");
    indexe:=StrMatch(datain,1,"e=");
    indexs:=StrMatch(datain,1,"/");
    
    MyErrData.cerr:=-1;
    MyErrData.cres:=-1;
    
    IF indexe > StrLen(datain) THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Tag e= missing in the reply from vision system.";
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Error: Tag e= missing in the reply from vision system.";
        ENDIF
    ELSE
        DataOK:=StrToVal(StrPart(datain,indexe+3,indexs-indexe-4),MyErrData.cerr);
        IF DataOK=FALSE THEN
            IF ASFM_LogErrors THEN
               Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Unable to convert field e into num value.";
            ENDIF
            IF ASFM_M_Lvl > 0 THEN
               TPWrite "Error: Unable to convert field e into num value.";
            ENDIF 
            !Stop;
        ENDIF
        DataOK:=StrToVal(StrPart(datain,indexr+3,indexe-indexr-5),MyErrData.cres);
        IF DataOK=FALSE THEN
            IF ASFM_LogErrors THEN
               Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Unable to convert field r into num value. ";
            ENDIF
            IF ASFM_M_Lvl > 0 THEN
               TPWrite "Error: Unable to convert field r into num value.";
            ENDIF
            !Stop;
        ENDIF
    ENDIF
    IF MyErrData.cerr <> 0 THEN
        IF ASFM_LogErrors THEN
            Write LogASFMErrors, CDate() + "; " +CTime() + "; Error in reply " +  "; e= ", \Num:=MyErrData.cerr;
        ENDIF
    ENDIF
    RETURN MyErrData;
ENDFUNC

!Connection with the vision system
!Uses global variables ASFM_IP_Add and ASFM_IP_Port to define the communication port
!NOTE: in user programs, use the function ASFMu_Initialize()
PROC ASFM_Connect()
    SocketClose ComASFMSocket;
    SocketCreate ComASFMSocket;
    SocketConnect ComASFMSocket, ASFM_IP_Add, ASFM_IP_Port;
    ASFMLaserStatus:=2;
    ASFMInspectionStatus:=-2;
    ASFMSeqID:=0;
    IF ASFM_M_Lvl > 2 THEN
        TPWrite "Connection established with IP=" + ASFM_IP_Add + " on PORT=" + ValToStr(ASFM_IP_Port);
    ENDIF
ENDPROC

!Disconnection from the vision system
!No argument (module supports only one socket)
!NOTE: in user programs, use the function ASFMu_Clear()
PROC ASFM_Disconnect()
    SocketClose ComASFMSocket;
    IF ASFM_M_Lvl > 2 THEN
        TPWrite "Connection closed with IP=" + ASFM_IP_Add + " on PORT=" + ValToStr(ASFM_IP_Port);
    ENDIF
ENDPROC

!Intelligent laser state management function (avoid unecessary initialization delays)
!NOTE: The module variable ASFMLaserStatus contains the current state of the laser
!ASFMLaserStatus:
!    1=ON; 2=OFF; 3=MUTED; 4=PENDING(activating delay of 3 seconds...)
FUNC bool ASFMu_ToggleLaser(num CamID)
    VAR bool Fout;
    Fout:=FALSE;
    
    IF NOT ASFMu_GetStatus(CamID) THEN
        RETURN Fout;
    ENDIF
    IF ASFMLaserStatus=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Bad data in laser status. ";
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Error in laser status variable!";
        ENDIF
        RETURN Fout;
    ENDIF 
    IF ASFMLaserStatus=2 THEN
        !Laser is currently disabled
        IF NOT ASFMu_Enable(CamID) THEN
            RETURN Fout;
        ENDIF
            
        IF NOT ASFMu_LaserOn(CamID) THEN
            RETURN Fout;
        ENDIF
    ENDIF 
    IF ASFMLaserStatus=3 THEN
        !Laser is currently muted
        IF NOT ASFMu_LaserOn(CamID) THEN
            RETURN Fout;
        ENDIF
    ENDIF
    
    IF ASFMLaserStatus=1 THEN
        !Laser is currently ON (unmuted)
        IF NOT ASFMu_LaserOff(CamID) THEN
            RETURN Fout;
        ENDIF
    ENDIF
    
    IF NOT ASFMu_GetStatus(CamID) THEN
        RETURN Fout;
    ENDIF
    
    IF ASFM_M_Lvl>2 THEN 
       !1=ON; 2=OFF; 3=MUTED; 4=PENDING(3sec)
       IF ASFMLaserStatus = 1 THEN
           TPWrite "Laser is now ON";
       ENDIF
       IF ASFMLaserStatus = 2 THEN
           TPWrite "Laser is now OFF";
       ENDIF
       IF ASFMLaserStatus = 3 THEN
           TPWrite "Laser is now MUTED (zero power but enabled)";
       ENDIF
       IF ASFMLaserStatus = 4 THEN
           TPWrite "Laser is now activating (3 seconds safety activation delay in progress)";
       ENDIF
    ENDIF
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to enable the laser.  Includes the 3 seconds security delay at laser activation
!Includes the management of the error status in the reply
!ARGUMENT: CamID = Numeric value for the laser-camera on which the command will be applied (no string)
Func bool ASFMu_Enable(num CamID)
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num icorr;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+""" rts="""+ValToStr(ASFMSeqID-1)+ """><sen c=""" + ValToStr(CamID) +""" /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot enable laser. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Laser enable error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ELSE 
        ASFM_WaitTimeMs 3500;
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Laser is enabled by robot command";
        ENDIF
    ENDIF
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to disable the laser.  
!Includes the management of the error status in the reply
!ARGUMENT: CamID = Numeric value for the laser-camera on which the command will be applied (no string)
FUNC bool ASFMu_Disable(num CamID)
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num icorr;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+""" rts="""+ValToStr(ASFMSeqID-1)+ """><sdi c=""" + ValToStr(CamID) +""" /></com>";
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
  
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot disable laser. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Laser disable error on vision system! Err="+ValToStr(comerr);
        ENDIF 
        RETURN Fout;
    ELSE 
       IF ASFM_M_Lvl > 2 THEN
           TPWrite "Laser is disabled by robot command";
        ENDIF
    ENDIF
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to activate (unmute) the laser.  
!Minimal delay of 100 ms included after function call.
!Includes the management of the error status in teh reply
!ARGUMENT: CamID = Numeric value for the laser-camera on which the command will be applied (no string)
FUNC bool ASFMu_LaserOn(num CamID)
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num icorr;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+""" rts="""+ValToStr(ASFMSeqID-1)+ """><son c=""" + ValToStr(CamID) +""" /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot unmute laser. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Laser on error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ELSE 
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Laser is on by robot command";
        ENDIF
    ENDIF
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to shut down (OFF) the laser.  Minimal delay of 100 ms included after function call.
!Includes the management of the error status in teh reply
!ARGUMENT: CamID = Numeric value for the laser-camera on which the command will be applied (no string)
FUNC bool ASFMu_LaserOff(num CamID)
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num icorr;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+""" rts="""+ValToStr(ASFMSeqID-1)+ """><sof c=""" + ValToStr(CamID) +""" /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF

    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot mute laser. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Laser off error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ELSE 
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Laser is muted by robot command (zero power)";
        ENDIF
    ENDIF
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to acknowledge any error event present on the system 
!(replies are all in error if a critical event is present and not acknowledged...)
FUNC bool ASFMu_Acknowledge()
    VAR string comstr;
    !VAR num tSF;
    !VAR dnum tSFd;   
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num icorr;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><ack /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot send acknowledge command. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Acknowledge error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ELSE 
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "All errors acknowledged from robot command";
        ENDIF
    ENDIF
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to read the current laser state.
!ARGUMENT: CamID = Numeric value for the laser-camera on which the command will be applied (no string)
!Includes the management of the error status in teh reply
FUNC bool ASFMu_GetStatus(num CamID) 
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexstat;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num status;
    VAR num icorr;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><gst c=""" + ValToStr(CamID) +""" /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,1,"e=");
    indexstat:=StrMatch(stASFMReceived,1," s=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get current laser status. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl>0 THEN 
           TPWrite "GetStatus error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ENDIF
    IF indexstat < StrLen(stASFMReceived) then
        dataok:=StrToVal(StrPart(stASFMReceived,indexstat+4,indexr-indexstat-6),status);
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Laser status: "+ValToStr(status);
        ENDIF
        ASFMLaserStatus:=status;
    ELSE 
        ASFMLaserStatus:=-1;
    ENDIF
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to select a task on the system.  Minimal delay of 100 ms included after function call.
!ARGUMENT: TaskID = Numeric value for the task to select (no string)
!Includes the management of the error status in teh reply
FUNC bool ASFMu_SelectTask(num TaskID)
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num icorr;
    VAR num NbBytes;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><spa n=""tnu"" v="""+ValToStr(TaskID)+""" /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot select task. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Task selection error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ELSE
        IF ASFM_M_Lvl > 2 THEN 
           TPWrite "Task # " + ValToStr(TaskID) + " was selected by robot";    
        ENDIF
    ENDIF
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to Set the parameter to have the tag "e=" in all replies.
!This function is used by the ASFMu_Initialize() function
FUNC bool ASFM_SetTagE( )
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num icorr;
    VAR num NbBytes;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><spa n=""zec"" v=""1"" /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot set parameter zec. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Set e tag error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ELSE 
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Parameter zec was set to have e tag in all replies";
        ENDIF
    ENDIF 
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to set the corner angle for the SF5 function.
!ARGUMENT: angle in degrees (num format)
!This function is used by ASFM functions requiring the Angle parameter (pca)
FUNC bool ASFM_SetAngle(num Angle)
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num icorr;
    VAR num NbBytes;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><spa n=""pca"" v=""" + ValToStr(Angle) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot set parameter spa. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Set angle parameter error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ELSE 
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Parameter pca was set to define corner angle for ASFM function";
        ENDIF
    ENDIF 
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to set the segment distance for the SF6 and SF9 functions.
!ARGUMENT: distance in mm (num format)
!This function is used by ASFM functions requiring the Distance parameter (ple)
FUNC bool ASFM_SetDistance(num Dist)
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num icorr;
    VAR num NbBytes;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><spa n=""ple"" v=""" + ValToStr(Dist) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot set parameter ple. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Set distance parameter error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ELSE 
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Parameter ple was set to define segment length for ASFM function";
        ENDIF
    ENDIF 
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to set the intersection tolerance for the SF4 and SF6 functions.
!ARGUMENT: distance in mm (num format)
!This function is used by ASFM functions requiring the Distance Tolerance parameter (dbl)
FUNC bool ASFM_SetTolerance(num Dist)
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num icorr;
    VAR num NbBytes;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><spa n=""dbl"" v=""" + ValToStr(Dist) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot set parameter dbl. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Set tolerance parameter error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ELSE 
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Parameter dbl was set to define intersection tolerance for ASFM function";
        ENDIF
    ENDIF 
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to Start the inspection process on the selected laser-camera
!ARGUMENTS:
!   CamID = Numeric value for the laser-camera to use (can be 0 or 1; no string)
!   PartName = String representing the name for the inspection (max. 50 characters)
!Includes the management of the error status in the reply
FUNC bool ASFMu_StartInspection(num CamID,string PartName)
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num icorr;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    IF StrLen(PartName) > 49 THEN 
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Part name for inspection is too long (max. 50).";
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Error: part name is longer than 50 characters!";
        ENDIF
        RETURN FALSE;
    ENDIF 
    
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+ """><sai c=""" + ValToStr(CamID) + """ p=""" + PartName +""" /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot start inspection. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Start inspection error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ELSE 
        ASFMInspectionStatus:=-2;
        IF ASFM_M_Lvl > 2 THEN
            TPWrite "Inspection started on camera " + ValToStr(CamID) + " with part name=" + PartName;
        ENDIF
    ENDIF
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to stop the inspection process on selected laser-camera.  Minimal delay of 100 ms included after function call.
!ARGUMENT: CamID = Numeric value for the laser-camera to select (no string)
!Includes the management of the error status in the reply
FUNC bool ASFMu_StopInspection(num CamID)
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num icorr;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+ """><soi c=""" + ValToStr(CamID) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot stop inspection. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Stop inspection error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ELSE 
        IF ASFM_M_Lvl > 2 THEN
            TPWrite "Inspection stopped from robot command on camera " + ValToStr(CamID);
        ENDIF
    ENDIF
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to retrieve the inspection result for the selected laser-camera.  
!ARGUMENT: CamID = Numeric value for the laser-camera to select (no string)
!Includes the management of the error status in the reply
FUNC bool ASFMu_GetInspectionResult(num CamID) 
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexres;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num status;
    VAR num icorr;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><gir c=""" + ValToStr(CamID) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,1,"e=");
    indexres:=StrMatch(stASFMReceived,1," d=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get inspection result. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "GetStatus error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ENDIF
    IF indexres < StrLen(stASFMReceived) then
        dataok:=StrToVal(StrPart(stASFMReceived,indexres+4,indexr-indexres-6),status);
        ASFMInspectionStatus:=status;
        IF ASFM_M_Lvl > 2 THEN
            IF status = 0 THEN
               TPWrite "Inspection status is failed for camera " + ValToStr(CamID) ;
            ENDIF
            IF status = 1THEN
               TPWrite "Inspection status is no match (bad algorithm configuration) for camera " + ValToStr(CamID);
            ENDIF
            IF status = 2 THEN
               TPWrite "Inspection status is warning (tending to defect) for camera " + ValToStr(CamID) ;
            ENDIF
            IF status = 3 THEN
               TPWrite "Inspection status is good for camera " + ValToStr(CamID) ;
            ENDIF
        ENDIF
    ELSE 
        ASFMInspectionStatus:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: No inspection result received. Cam= ", \Num:=CamID;
        ENDIF
        IF ASFM_M_Lvl>0 THEN
            TPWrite "Error: No inspection result returned for camera " + ValToStr(CamID) ;
            RETURN Fout;
        ENDIF
    ENDIF 
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to retrieve the tracking point for the selected laser-camera.  
!Includes the management of the error status in the reply
!Output:
!  caldata.ty / tz = YZ of tracking point in OPTICAL frame (no X and no orientation)
FUNC caldata ASFMu_GetVisionTP() 
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexres;
    VAR num indexres2;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num status;
    VAR num icorr;
    VAR bool dataok;
    
    VAR caldata DataOut;
    DataOut.Status:=-1;
    WaitTime 0.2;
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><gvis /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,1,"e=");
    indexres:=StrMatch(stASFMReceived,1," y=");
    indexres2:=StrMatch(stASFMReceived,1," z=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get tracking point data. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "GetTrackingPoint error on vision system! Err="+ValToStr(comerr);
        ENDIF
        DataOut.status:=-1;
        RETURN DataOut;
    ENDIF
    IF indexres < StrLen(stASFMReceived) then
        !Original conversion
        dataok:=StrToVal(StrPart(stASFMReceived,indexres+4,indexs-indexres2-6),DataOut.ty);
        IF NOT dataok THEN
            !In some cases, two spaces after y...
            dataok:=StrToVal(StrPart(stASFMReceived,indexres+4,indexs-indexres2-7),DataOut.ty);
            IF NOT dataok THEN
                TPWrite "YDataString_S0E0: " + StrPart(stASFMReceived,indexres+4,indexs-indexres2-6) + "ConversionOK: " + ValToStr(StrToVal(StrPart(stASFMReceived,indexres+4,indexs-indexres2-6),DataOut.ty));
                TPWrite "YDataString_S0E1: " + StrPart(stASFMReceived,indexres+4,indexs-indexres2-7) + "ConversionOK: " + ValToStr(StrToVal(StrPart(stASFMReceived,indexres+4,indexs-indexres2-7),DataOut.ty));
                TPWrite "YDataString_S1E0: " + StrPart(stASFMReceived,indexres+5,indexs-indexres2-6) + "ConversionOK: " + ValToStr(StrToVal(StrPart(stASFMReceived,indexres+5,indexs-indexres2-6),DataOut.ty));
                TPWrite "YDataString_S1E1: " + StrPart(stASFMReceived,indexres+5,indexs-indexres2-7) + "ConversionOK: " + ValToStr(StrToVal(StrPart(stASFMReceived,indexres+5,indexs-indexres2-7),DataOut.ty));
                DataOut.status:=-2;
                RETURN DataOut;
            ENDIF
        ENDIF
        dataok:=StrToVal(StrPart(stASFMReceived,indexres2+4,indexs-indexres2-6),DataOut.tz);
        IF NOT dataok THEN
            TPWrite "ZDataString: " + StrPart(stASFMReceived,indexres+4,indexs-indexres2-6);
            DataOut.status:=-3;
            RETURN DataOut;
        ENDIF
    ELSE 
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Tracking data is empty.";
        ENDIF
        IF ASFM_M_Lvl>0 THEN
            TPWrite "Error: No tracking point data returned from camera ";
            DataOut.status:=-4;
            RETURN DataOut;
        ENDIF
    ENDIF 
    DataOut.Status:=1;
    RETURN DataOut;
ENDFUNC

!Function to control the LED state on the laser-camera. Minimal delay of 100 ms included after function call.
!NOTE: No effect if current laser-camera does not have LEDs
!ARGUMENTS:
!    CamID = Numeric value for the laser-camera to select (no string)
!    State = Numeric value for the LED state (0=OFF; 1=ON)
!Includes the management of the error status in the reply
FUNC bool ASFMu_Led(num CamID, num State) 
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num status;
    VAR num icorr;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    IF CamID > 1 THEN 
        CamID:=0;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Incorrect camera ID (0-1).";
        ENDIF
        IF ASFM_M_Lvl > 0 THEN 
            TPWrite "Error: Camera ID has an incorrect value (accepted: 0 or 1)!";
        ENDIF 
        !Stop;
        RETURN Fout;
    ENDIF 
    IF State > 1 THEN 
        State:=0;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Incorrect value for LED state (0-1).";
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Error: LED state has an incorrect value (accepted: 0 or 1)!";
        ENDIF 
        !Stop;
        RETURN Fout;
    ENDIF 
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><led c=""" + ValToStr(CamID) + """ pwr=""" +ValToStr(State*100)+ """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot chnage LED state. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Led command error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ELSE 
        IF ASFM_M_Lvl > 2 THEN
            IF State = 0 THEN
                TPWrite "Led light is now OFF by robot command";
            ENDIF
            IF State = 1 THEN
                TPWrite "Led light is now ON by robot command";
            ENDIF 
        ENDIF
    ENDIF
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to control the LCD shutter state on the laser-camera. Minimal delay of 100 ms included after function call.
!NOTE: No effect if current laser-camera does not have an LCD on its video channel
!ARGUMENTS:
!    CamID = Numeric value for the laser-camera to select (no string)
!    Att = Numeric value for the Attenuation state (0=OFF(0%); 1=ON(200%))
!Includes the management of the error status in the reply
FUNC bool ASFMu_Lcd(num CamID, num Att) 
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num status;
    VAR num icorr;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    IF CamID > 1 THEN 
        CamID:=0;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Incorrect value for camera ID (0-1)";
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Error: Camera ID has an incorrect value (accepted: 0 or 1)!";
        ENDIF
        RETURN Fout;
    ENDIF 
    IF Att > 1 THEN 
        Att:=0;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Incorrect value for LCD attenuation (0-1). Err= ";
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Error: LCD attenuation has an incorrect value (accepted: 0 or 1)!";
        ENDIF
        RETURN Fout;
    ENDIF 
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><lcd c=""" + ValToStr(CamID) + """ att=""" +ValToStr(Att*100)+ """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot change LCD attenuation. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Lcd command error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ELSE 
        IF ASFM_M_Lvl > 2 THEN
            IF Att = 0 THEN
                TPWrite "Video shutter is now OPENED by robot command";
            ENDIF
            IF Att = 1 THEN
                TPWrite "Video shutter is now CLOSED by robot command";
            ENDIF 
        ENDIF
    ENDIF
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to control the video output mode on the laser-camera. Minimal delay of 100 ms included after function call.
!NOTE: No effect if current laser-camera does not have a compatible video channel
!IMPORTANT: Functions sends two commands: svm and svf since complete commmand was longer than 80 characters...
!ARGUMENTS:
!    CamID = Numeric value for the laser-camera to select (no string)
!    State = Numeric value for the streaming state (0=OFF; 1=ON)
!    Mode  = Numeric value for the video mode (0=VGA; 1=Ethernet stream)
!    Fps   = Numeric value for the number of frames per second (1 to 20)
!Includes the management of the error status in the reply (separated for Part 1 and Part 2)
FUNC bool ASFMu_SetVideo(num CamID, num State, num Mode, num Fps) 
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num status;
    VAR num icorr;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    IF CamID > 1 THEN 
        CamID:=0;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Incorrect value for camera ID (0-1).";
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Error: Camera ID has an incorrect value (accepted: 0 or 1)!";
        ENDIF
        !Stop;
        RETURN Fout;
    ENDIF 
    IF State > 1 THEN 
        State:=0;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Incorrect value for video state (0-1).";
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Error: State parameter has an incorrect value (accepted: 0 or 1)!";
        ENDIF
        RETURN Fout;
    ENDIF 
    IF Mode > 1 THEN 
        Mode:=0;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Incorrect value for video mode (0-1).";
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Error: Mode parameter has an incorrect value (accepted: 0 or 1)!";
        ENDIF
        RETURN Fout;
    ENDIF 
    IF Fps > 20 THEN 
        Fps:=5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Incorrect value for video frame rate (1-20)", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Error: Fps parameter has an incorrect value (accepted: 1 to 20)!";
        ENDIF
        RETURN Fout;
    ENDIF
    !Send first part of command with c, State and Mode
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><svm c=""" + ValToStr(CamID) + """ sts=""" + ValToStr(State) + """ mod=""" + ValToStr(Mode) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot change video state (part 1). Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Set video command error (part 1) on vision system! Err=" + ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ELSE 
        IF ASFM_M_Lvl > 2 THEN
            IF Mode = 0 THEN
               TPWrite "Video mode for camera " + ValToStr(CamID) + "is VGA";
            ENDIF
            IF Mode = 1 THEN
               TPWrite "Video mode for camera " + ValToStr(CamID) + "is Ethernet streaming";
            ENDIF
            IF State = 0 THEN
                TPWrite "Video output for camera " + ValToStr(CamID) + "is disabled";
            ENDIF
            IF State = 0 THEN
                TPWrite "Video output for camera " + ValToStr(CamID) + "is enabled";
            ENDIF
        ENDIF
    ENDIF
    !Send second command for the other argument FrameRate (with c again)...
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><svf c=""" + ValToStr(CamID) + """ v=""" + ValToStr(Fps) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot change video state (part 2). Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Set video command error (part 2) on vision system! Err="+ ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ELSE 
        IF ASFM_M_Lvl > 2 THEN
            TPWrite "Video frame rate for camera " + ValToStr(CamID) + "is " + ValToStr(Fps);
        ENDIF
    ENDIF
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to control the audio output mode on the laser-camera. Minimal delay of 100 ms included after function call.
!NOTE: No effect if current laser-camera does not have a compatible audio channel
!ARGUMENTS:
!    CamID = Numeric value for the laser-camera to select (no string)
!    State = Numeric value for the state of streaming (0=OFF; 1=ON)
!    Mode = Numeric value for the video mode (0=Analog; 1=Ethernet stream)
!Includes the management of the error status in the reply
FUNC bool ASFMu_SetAudio(num CamID, num State, num Mode) 
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num status;
    VAR num icorr;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    IF CamID > 1 THEN 
        CamID:=0;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Incorrect value for camera ID (0-1).", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Error: Camera ID has an incorrect value (accepted: 0 or 1)!";
        ENDIF
        RETURN Fout;
    ENDIF 
    IF Mode > 1 THEN 
        Mode:=0;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Incorrect value for audio mode (0-1).", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Error: Mode parameter has an incorrect value (accepted: 0 or 1)!";
        ENDIF
        RETURN Fout;
    ENDIF 
    IF State > 1 THEN 
        State:=0;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Incorrect value for audio state (0-1).", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Error: State parameter has an incorrect value (accepted: 0 or 1)!";
        ENDIF
        RETURN Fout;
    ENDIF 
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><sas c=""" + ValToStr(CamID) + """ sts=""" +ValToStr(State) + """ mod=""" +ValToStr(Mode) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot change audio state. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Set audio command error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ELSE 
        IF ASFM_M_Lvl > 2 THEN
            IF Mode = 0 THEN
               TPWrite "Audio mode for camera " + ValToStr(CamID) + "is Analog";
            ENDIF
            IF Mode = 1 THEN
               TPWrite "Audio mode for camera " + ValToStr(CamID) + "is Ethernet streaming";
            ENDIF
            IF State = 0 THEN
                TPWrite "Audio output for camera " + ValToStr(CamID) + "is disabled";
            ENDIF
            IF State = 0 THEN
                TPWrite "Audio output for camera " + ValToStr(CamID) + "is enabled";
            ENDIF  
        ENDIF
    ENDIF
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to retrieve the distance measurement for the selected laser-camera.
!ARGUMENT: 
!    CamID = Numeric value for the laser-camera to select (no string)
!OUTPUT: 
!    num   = Distance in mm from the CAMERA reference down to the acquired point (Distance = -1 if error)
!Includes the management of the error status in the reply
FUNC num ASFMu_GetDistance (num CamID)    
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexres;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num DistZ;
    VAR num icorr;
    VAR bool dataok;
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><gdi c=""" + ValToStr(CamID) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,1,"e=");
    indexres:=StrMatch(stASFMReceived,1," d=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    
    IF indexe > StrLen(stASFMReceived) THEN !there is no error, d comes after r in reply
        indexok:=indexs; 
        icorr:=4;
    ELSE !there is an error, e comes after r in reply
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexres+3,indexok-indexres-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get distance value. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "GetDistance error on vision system! Err="+ValToStr(comerr);
        ENDIF
        RETURN -1;
        RETURN -1;
    ELSE 
        IF indexres < StrLen(stASFMReceived) then
            dataok:=StrToVal(StrPart(stASFMReceived,indexres+4,indexr-indexres-6),DistZ);
            IF ASFM_M_Lvl > 2 THEN
               TPWrite "Distance: " + ValToStr(DistZ);
            ENDIF
            RETURN DistZ;
        ELSE 
            RETURN -1;
        ENDIF 
    ENDIF
ENDFUNC 

!Function to set the seam finding mode to use for next commands.
!NOTE: ASFM module licence required on vision system to use this command
!ARGUMENTS:
!    SFType = Numeric value for search type (no string) - 0 to 20 supported
!    SFMode = Numeric value for measurement mode (no string) - 0=REFERENCE; 1=CURRENT
!    SFSeq = Sequential number to identify measurement position (no string) - 1 to 999
!    SFTAsk = Task to select for measurement command in this sequence (no string) - 1 to 255 (if -1, no change on current task)
!OUTPUT:
!    bool = TRUE if function received no error; FALSE otherwise
FUNC bool ASFM_BeginJointFinding(num SFType, num SFMode, num SFSeq, num SFTask) 
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexs2;
    VAR num indexres;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num icorr;
    VAR bool dataok;
    VAR bool Fout;
    Fout := FALSE;
    
    IF NOT ASFMu_SelectTask(SFTask) THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot select task";
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Cannot select task before ASFM initialization!";
        ENDIF 
        RETURN Fout;
    ENDIF
    
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><bas tp=""" + ValToStr(SFType) + """ sq=""" + ValToStr(SFSeq) + """ md=""" + ValToStr(SFMode) + """ tnu=""" + ValToStr(-1) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    !Header
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,1,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,">");
    indexs2:=StrMatch(strpart(stASFMReceived,1,indexr+3),indexr,"/");
    
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        IF indexs2 > 0 THEN 
        icorr:=4;
        ELSE
            icorr:=5;
        ENDIF 
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-5),comerr);
    ENDIF
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot initialize ASFM mode. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "BeginJointFinding error on vision system! Err="+ValToStr(comerr);
        ENDIF 
        RETURN Fout;
    ELSE
        IF ASFM_M_Lvl > 2 THEN
           IF SFMode=0 THEN 
              TPWrite "BJF command sent in mode SF" + ValToStr(SFType) + "for REF acquisition (Seq=" +ValToStr(SFSeq) + "Task=" + ValToStr(SFTask) + ")";
           ENDIF 
           IF SFMode=1 THEN 
              TPWrite "BJF command sent in mode SF" + ValToStr(SFType) + "for CUR acquisition (Seq=" +ValToStr(SFSeq) + "Task=" + ValToStr(SFTask) + ")";
           ENDIF
        ENDIF        
    ENDIF
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to acquire a measurement in the seam finding mode (ASFM)
!NOTE: Function ASFM_BeginJointFinding() required before this command is sent.
!ARGUMENTS:
!    SFLength = Numeric value for filter length (no string) - 1 to 15 supported
!    SFIndex = Numeric value for measurement index (no string) - 1 to 5 supported (requirement based on selected mode)
!OUTPUT:
!    bool = TRUE if function received no error; FALSE otherwise
FUNC bool ASFM_AcquireMeasure(num SFLength, num SFIndex) 
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexs2;
    
    VAR num indexres;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
  
    VAR num icorr;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><acq l=""" + ValToStr(SFLength) + """ i=""" + ValToStr(SFIndex) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    !Header
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,1,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,">");
    indexs2:=StrMatch(strpart(stASFMReceived,1,indexr+3),indexr,"/");
    
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        IF indexs2 > 0 THEN 
        icorr:=4;
        ELSE
            icorr:=5;
        ENDIF 
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-5),comerr);
    ENDIF
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot acquire measure in ASFM. Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN 
           TPWrite "Acquire SF Measure error on vision system! Err="+ValToStr(comerr);
        ENDIF 
        RETURN Fout;
    ELSE 
        IF ASFM_M_Lvl > 2 THEN 
           TPWrite "SF Measurement acquired (Index=" + ValToStr(SFIndex) +")";
        ENDIF        
    ENDIF
    
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to send current TCP position and orientation (bja required before this command is sent).
!NOTE: Function ASFM_BeginJointFinding() required before this command is sent.
!ARGUMENTS:
!    None (uses current robot position)
!IMPORTANT:
!    The function reads internal variable gUseFlangeCalib to know if position must be sent
!    in TOOL coordinates or in FLANGE coordinates (see ASFMu_Initialize() function).
!OUTPUT:
!    bool = TRUE if function received no error; FALSE otherwise
FUNC bool ASFM_SendTCPData( ) 
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexs2;
    VAR robtarget p1;
    VAR num indexres;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
  
    VAR num icorr;
    VAR bool dataok;
    VAR bool Fout;
    Fout:=FALSE;
    
    IF NOT gUseFlangeCalib THEN
        IF CTool() <> MyToolASFM THEN
            IF ASFM_LogErrors THEN
            Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Tool changed since ASFM initialization.";
            ENDIF
            IF ASFM_M_Lvl > 0 THEN
            TPWrite "Error: Current Tool is different than wObj at initialization time!";
            ENDIF 
            RETURN Fout;
        ENDIF
        IF Cwobj() <> MyWobjASFM THEN
            IF ASFM_LogErrors THEN
                Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Base changed since ASFM initialization.";
            ENDIF
            IF ASFM_M_Lvl > 0 THEN
                TPWrite "Error: Current wObj is different than wObj at initialization time!";
            ENDIF 
            RETURN Fout;
        ENDIF
        ASFM_WaitTimeMs 100;
        p1 := CRobT(\Tool:=MyToolASFM \WObj:=MyWobjASFM);
        
        !If NO CALIBRATION, replace TCP data with NULL data...
        !p1.trans.x:=0;
        !p1.trans.y:=0;
        !p1.trans.z:=0;
        !p1.rot.q1:=1;
        !p1.rot.q2:=0;
        !p1.rot.q3:=0;
        !p1.rot.q4:=0;
        
        ASFM_WaitTimeMs 100;
    ELSE
        ASFM_WaitTimeMs 100;
        p1 := CRobT(\Tool:=NullToolASFM \WObj:=MyWobjASFM);                
        ASFM_WaitTimeMs 100;
        !If NO CALIBRATION, replace TCP data with NULL data...
        !p1.trans.x:=0;
        !p1.trans.y:=0;
        !p1.trans.z:=0;
        !p1.rot.q1:=1;
        !p1.rot.q2:=0;
        !p1.rot.q3:=0;
        !p1.rot.q4:=0;
    ENDIF
    
    
    !Part 1 (positions)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><stp d=""" + ValToStr(p1.trans.x) + " " + ValToStr(p1.trans.y) + " " + ValToStr(p1.trans.z) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    !Header
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,1,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,">");
    indexs2:=StrMatch(strpart(stASFMReceived,1,indexr+3),indexr,"/");
    
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        IF indexs2 > 0 THEN 
        icorr:=4;
        ELSE
            icorr:=5;
        ENDIF 
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-5),comerr);
    ENDIF
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot send TCP data (part1 ). Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Send TCP Data Part 1 error on vision system! Err="+ValToStr(comerr);
        ENDIF 
        RETURN Fout;
    ELSE
        IF ASFM_M_Lvl > 2 THEN 
           TPWrite "TCP data sent to SF module (Part1 XYZ)";
        ENDIF         
    ENDIF
    
     !Part 2 (orientations)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><sto d=""" + NumToStr(EulerZYX(\X,p1.rot),3) + " " + NumToStr(EulerZYX(\Y,p1.rot),3) + " " + NumToStr(EulerZYX(\Z,p1.rot),3) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    !Header
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,1,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,">");
    indexs2:=StrMatch(strpart(stASFMReceived,1,indexr+3),indexr,"/");
    
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        IF indexs2 > 0 THEN 
        icorr:=4;
        ELSE
            icorr:=5;
        ENDIF 
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-5),comerr);
    ENDIF
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot send TCP data (part 2). Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Send TCP Data Part 2 error on vision system! Err="+ValToStr(comerr);
        ENDIF 
        RETURN Fout;
    ELSE
        IF ASFM_M_Lvl > 2 THEN 
           TPWrite "TCP data sent to SF module (Part2 ABC)";
        ENDIF
    ENDIF
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to get seam finding correction data.
!NOTE: This is the last step of any ASFM sequence after measurement(s) have been acquired.
!ARGUMENTS:
!    SFIndex: define which value to retrieve based on active SF mode (no string) - value from 1 to 5
!OUTPUT: IMPORTANT: exact content changes based on function used
!    corrdata.tx / ty / tz = XYZ data of returned point 
!    corrdata.oa / ob / oc = ABC orientation data of returned point
!    corrdata.ar / gp / ms = Geometric data associated to measurement
FUNC corrdata  ASFM_GetCorrData(num SFIndex) 
    VAR string comstr;
    VAR string data;
    VAR num indexr;
    VAR num indexd;
    VAR num indexs;
    VAR num indexs2;
    VAR corrdata cdat;
    VAR errdata edat;
    VAR num icorr;
    VAR bool dataok;
    cdat.status:=-1;
    
    !Part 1 (positions)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><gcp i=""" + ValToStr(SFIndex) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=1000;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    edat:=ASFM_HasError(stASFMReceived);
    IF edat.cerr = -1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get ASFM correction data (part 1). Err= ", \Num:=edat.cerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Get SF Correction Part 1 error on vision system! Err="+ValToStr(edat.cerr);
        ENDIF 
        RETURN cdat;
    ENDIF
    
    IF edat.cres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get ASFM correction data (part 1). Err= ", \Num:=edat.cerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Get SF Correction Part 1 error on vision system! Err="+ValToStr(edat.cerr);
        ENDIF 
        RETURN cdat;
    ELSE
        indexd:=StrMatch(stASFMReceived,1,"d=");
        indexr:=StrMatch(stASFMReceived,indexd,"r=");
        data:=StrPart(stASFMReceived,indexd,indexr-indexd);
        indexs:=StrMatch(data,1," ");
        dataok:=StrToVal(StrPart(data,1+3,indexs-1-1),cdat.i);
        indexs2:=StrMatch(data,indexs+1," ");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.tx);
        indexs:=StrMatch(data,indexs2+1," ");
        dataok:=StrToVal(StrPart(data,indexs2+1,indexs-indexs2-1),cdat.ty);
        indexs2:=StrMatch(data,indexs+1,"""");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.tz);
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Correction data from SF: i=" + ValToStr(cdat.i) + " x=" + ValToStr(cdat.tx) + " y=" + ValToStr(cdat.ty) + " z=" + ValToStr(cdat.tz);
        ENDIF
    ENDIF
    
    !Part 2 (orientations)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><gca i=""" + ValToStr(SFIndex) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=1000;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
 
    edat:=ASFM_HasError(stASFMReceived);
    IF edat.cerr = -1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get ASFM correction (part 2). Err= ", \Num:=edat.cerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Get SF Correction Part 2 error on vision system! Err="+ValToStr(edat.cerr);
        ENDIF 
        RETURN cDat;
    ENDIF
    
    IF edat.cres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get ASFM correction (part 2). Err= ", \Num:=edat.cerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Get SF Correction Part 2 error on vision system! Err="+ValToStr(edat.cerr);
        ENDIF 
        RETURN cdat;
    ELSE
        indexd:=StrMatch(stASFMReceived,1,"d=");
        indexr:=StrMatch(stASFMReceived,indexd,"r=");
        data:=StrPart(stASFMReceived,indexd,indexr-indexd);
        indexs:=StrMatch(data,1," ");
        indexs:=StrMatch(data,1," ");
        dataok:=StrToVal(StrPart(data,1+3,indexs-1-1),cdat.i);
        indexs2:=StrMatch(data,indexs+1," ");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.oa);
        indexs:=StrMatch(data,indexs2+1," ");
        dataok:=StrToVal(StrPart(data,indexs2+1,indexs-indexs2-1),cdat.ob);
        indexs2:=StrMatch(data,indexs+1,"""");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.oc);
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Correction data from SF: i=" + ValToStr(cdat.i) + " a=" + ValToStr(cdat.oa) + " b=" + ValToStr(cdat.ob) + " c=" + ValToStr(cdat.oc);
        ENDIF
    ENDIF
  
    !Part 3 (geometric)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><gcg i=""" + ValToStr(SFIndex) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=1000;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF
 
    edat:=ASFM_HasError(stASFMReceived);
    IF edat.cerr = -1 THEN
        Stop;
    ENDIF
    
    IF edat.cres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get ASFM correction (part 3). Err= ", \Num:=edat.cerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Get SF Correction Part 3 error on vision system! Err="+ValToStr(edat.cerr);
        ENDIF 
        RETURN cdat;
    ELSE
        indexd:=StrMatch(stASFMReceived,1,"d=");
        indexr:=StrMatch(stASFMReceived,indexd,"r=");
        data:=StrPart(stASFMReceived,indexd,indexr-indexd);
        indexs:=StrMatch(data,1," ");
        indexs:=StrMatch(data,1," ");
        dataok:=StrToVal(StrPart(data,1+3,indexs-1-1),cdat.i);
        indexs2:=StrMatch(data,indexs+1," ");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.gp);
        indexs:=StrMatch(data,indexs2+1," ");
        dataok:=StrToVal(StrPart(data,indexs2+1,indexs-indexs2-1),cdat.ms);
        indexs2:=StrMatch(data,indexs+1,"""");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.ar);
        cdat.Status:=3;
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Correction data from SF: i=" + ValToStr(cdat.i) + " ar=" + ValToStr(cdat.ar) + " gp=" + ValToStr(cdat.gp) + " ms=" + ValToStr(cdat.ms);
        ENDIF
    ENDIF
    RETURN cdat;
ENDFUNC

!Function to get seam finding correction data (without geometric data).
!NOTE: This is the last step of any ASFM sequence after measurement(s) have been acquired.
!ARGUMENTS:
!    SFIndex: define which value to retrieve based on active SF mode (no string) - value from 1 to 5
!OUTPUT: IMPORTANT: exact content changes based on function used
!    corrdata.tx / ty / tz = XYZ data of returned point 
!    corrdata.oa / ob / oc = ABC data of returned point
!    corrdata.ar / gp / ms = Not read
FUNC corrdata  ASFM_GetCorrDataNoGeo(num SFIndex) 
    VAR string comstr;
    VAR string data;
    VAR num indexr;
    VAR num indexd;
    VAR num indexs;
    VAR num indexs2;
    VAR corrdata cdat;
    VAR errdata edat;
    VAR num icorr;
    VAR bool dataok;
    cdat.status:=-1;
    
    !Part 1 (positions)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><gcp i=""" + ValToStr(SFIndex) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=1000;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    edat:=ASFM_HasError(stASFMReceived);
    IF edat.cerr = -1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get ASFM correction data (part 1). Err= ", \Num:=edat.cerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Get SF Correction Part 1 error on vision system! Err="+ValToStr(edat.cerr);
        ENDIF 
        RETURN cdat;
    ENDIF
    
    IF edat.cres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get ASFM correction data (part 1). Err= ", \Num:=edat.cerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Get SF Correction Part 1 error on vision system! Err="+ValToStr(edat.cerr);
        ENDIF 
        RETURN cdat;
    ELSE
        indexd:=StrMatch(stASFMReceived,1,"d=");
        indexr:=StrMatch(stASFMReceived,indexd,"r=");
        data:=StrPart(stASFMReceived,indexd,indexr-indexd);
        indexs:=StrMatch(data,1," ");
        dataok:=StrToVal(StrPart(data,1+3,indexs-1-1),cdat.i);
        indexs2:=StrMatch(data,indexs+1," ");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.tx);
        indexs:=StrMatch(data,indexs2+1," ");
        dataok:=StrToVal(StrPart(data,indexs2+1,indexs-indexs2-1),cdat.ty);
        indexs2:=StrMatch(data,indexs+1,"""");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.tz);
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Correction data from SF: i=" + ValToStr(cdat.i) + " x=" + ValToStr(cdat.tx) + " y=" + ValToStr(cdat.ty) + " z=" + ValToStr(cdat.tz);
        ENDIF
    ENDIF
    
    !Part 2 (orientations)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><gca i=""" + ValToStr(SFIndex) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=1000;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
 
    edat:=ASFM_HasError(stASFMReceived);
    IF edat.cerr = -1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get ASFM correction (part 2). Err= ", \Num:=edat.cerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Get SF Correction Part 2 error on vision system! Err="+ValToStr(edat.cerr);
        ENDIF 
        RETURN cDat;
    ENDIF
    
    IF edat.cres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get ASFM correction (part 2). Err= ", \Num:=edat.cerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Get SF Correction Part 2 error on vision system! Err="+ValToStr(edat.cerr);
        ENDIF 
        RETURN cdat;
    ELSE
        indexd:=StrMatch(stASFMReceived,1,"d=");
        indexr:=StrMatch(stASFMReceived,indexd,"r=");
        data:=StrPart(stASFMReceived,indexd,indexr-indexd);
        indexs:=StrMatch(data,1," ");
        indexs:=StrMatch(data,1," ");
        dataok:=StrToVal(StrPart(data,1+3,indexs-1-1),cdat.i);
        indexs2:=StrMatch(data,indexs+1," ");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.oa);
        indexs:=StrMatch(data,indexs2+1," ");
        dataok:=StrToVal(StrPart(data,indexs2+1,indexs-indexs2-1),cdat.ob);
        indexs2:=StrMatch(data,indexs+1,"""");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.oc);
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Correction data from SF: i=" + ValToStr(cdat.i) + " a=" + ValToStr(cdat.oa) + " b=" + ValToStr(cdat.ob) + " c=" + ValToStr(cdat.oc);
        ENDIF
    ENDIF
    
    cdat.Status:=3;
    RETURN cdat;
ENDFUNC

!Function to get seam finding correction data (without orientation data and without geometric data).
!NOTE: This is the last step of any ASFM sequence after measurement(s) have been acquired.
!ARGUMENTS:
!    SFIndex: define which value to retrieve based on active SF mode (no string) - value from 1 to 5
!OUTPUT: IMPORTANT: exact content changes based on function used
!    corrdata.tx / ty / tz = XYZ data of returned point 
!    corrdata.oa / ob / oc = Not read
!    corrdata.ar / gp / ms = Not read
FUNC corrdata  ASFM_GetCorrDataNoOriNoGeo(num SFIndex) 
    VAR string comstr;
    VAR string data;
    VAR num indexr;
    VAR num indexd;
    VAR num indexs;
    VAR num indexs2;
    VAR corrdata cdat;
    VAR errdata edat;
    VAR num icorr;
    VAR bool dataok;
    cdat.status:=-1;
    
    !Part 1 (positions)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><gcp i=""" + ValToStr(SFIndex) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=1000;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    edat:=ASFM_HasError(stASFMReceived);
    IF edat.cerr = -1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get ASFM correction data (part 1). Err= ", \Num:=edat.cerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Get SF Correction Part 1 error on vision system! Err="+ValToStr(edat.cerr);
        ENDIF 
        RETURN cdat;
    ENDIF
    
    IF edat.cres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get ASFM correction data (part 1). Err= ", \Num:=edat.cerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Get SF Correction Part 1 error on vision system! Err="+ValToStr(edat.cerr);
        ENDIF 
        RETURN cdat;
    ELSE
        indexd:=StrMatch(stASFMReceived,1,"d=");
        indexr:=StrMatch(stASFMReceived,indexd,"r=");
        data:=StrPart(stASFMReceived,indexd,indexr-indexd);
        indexs:=StrMatch(data,1," ");
        dataok:=StrToVal(StrPart(data,1+3,indexs-1-1),cdat.i);
        indexs2:=StrMatch(data,indexs+1," ");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.tx);
        indexs:=StrMatch(data,indexs2+1," ");
        dataok:=StrToVal(StrPart(data,indexs2+1,indexs-indexs2-1),cdat.ty);
        indexs2:=StrMatch(data,indexs+1,"""");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.tz);
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Correction data from SF: i=" + ValToStr(cdat.i) + " x=" + ValToStr(cdat.tx) + " y=" + ValToStr(cdat.ty) + " z=" + ValToStr(cdat.tz);
        ENDIF
    ENDIF
    
    cdat.Status:=3;
    RETURN cdat;
ENDFUNC


!Function to get measurement geometric data (full SF sequence required before this command is sent).
!NOTE: This is the last step of any ASFM sequence after measurement(s) have been acquired.
!ARGUMENTS:
!    SFIndex: define which value to retrieve based on active SF mode (no string) - value from 1 to 5
!OUTPUT: IMPORTANT: exact content changes based on function used
!    corrdata.ar / gp / ms = Geometric data associated to measurement
FUNC corrdata  ASFM_GetGeoData(num SFIndex) 
    VAR string comstr;
    VAR string data;
    VAR num indexr;
    VAR num indexd;
    VAR num indexs;
    VAR num indexs2;
    VAR corrdata cdat;
    VAR errdata edat;
    VAR num icorr;
    VAR bool dataok;
    cdat.status:=-1;
    
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><gcg i=""" + ValToStr(SFIndex) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=1000;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF
 
    edat:=ASFM_HasError(stASFMReceived);
    IF edat.cerr = -1 THEN
        Stop;
    ENDIF
    
    IF edat.cres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get ASFM correction (part 3). Err= ", \Num:=edat.cerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Get SF Correction Part 3 error on vision system! Err="+ValToStr(edat.cerr);
        ENDIF 
        RETURN cdat;
    ELSE
        indexd:=StrMatch(stASFMReceived,1,"d=");
        indexr:=StrMatch(stASFMReceived,indexd,"r=");
        data:=StrPart(stASFMReceived,indexd,indexr-indexd);
        indexs:=StrMatch(data,1," ");
        indexs:=StrMatch(data,1," ");
        dataok:=StrToVal(StrPart(data,1+3,indexs-1-1),cdat.i);
        indexs2:=StrMatch(data,indexs+1," ");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.gp);
        indexs:=StrMatch(data,indexs2+1," ");
        dataok:=StrToVal(StrPart(data,indexs2+1,indexs-indexs2-1),cdat.ms);
        indexs2:=StrMatch(data,indexs+1,"""");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.ar);
        cdat.Status:=3;
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Correction data from SF: i=" + ValToStr(cdat.i) + " ar=" + ValToStr(cdat.ar) + " gp=" + ValToStr(cdat.gp) + " ms=" + ValToStr(cdat.ms);
        ENDIF
    ENDIF
    RETURN cdat;
ENDFUNC

!Function to get seam finding correction data.
!NOTE: This is the last step of the ASFM sequence after acquiring measure on one point.
!ARGUMENTS:
!    None
!OUTPUT: IMPORTANT: exact content changes based on function used
!    corrdata.tx / ty / tz = XYZ data of returned point 
!    corrdata.oa / ob / oc = ABC orientation data of returned point
!    corrdata.ar / gp / ms = Geometric data associated to measurement
FUNC corrdata  ASFM_GetPointData() 
    VAR string comstr;
    VAR string data;
    VAR num indexr;
    VAR num indexd;
    VAR num indexs;
    VAR num indexs2;
    VAR corrdata cdat;
    VAR errdata edat;
    VAR num icorr;
    VAR bool dataok;
    cdat.status:=-1;
    
    !Part 1 (positions)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><gcp i=""" + ValToStr(4) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    edat:=ASFM_HasError(stASFMReceived);
    IF edat.cerr = -1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get ASFM point data (part 1). Err= ", \Num:=edat.cerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Get SF Point Part 1 error on vision system! Err="+ValToStr(edat.cerr);
        ENDIF 
        RETURN cdat;
        !Stop;
        !ASFMu_Acknowledge;
    ENDIF
    
    IF edat.cres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get ASFM point data (part 1). Err= ", \Num:=edat.cerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Get SF Point Part 1 error on vision system! Err="+ValToStr(edat.cerr);
        ENDIF 
        RETURN cdat;
        !Stop;
        !ASFMu_Acknowledge;
    ELSE
        indexd:=StrMatch(stASFMReceived,1,"d=");
        indexr:=StrMatch(stASFMReceived,indexd,"r=");
        data:=StrPart(stASFMReceived,indexd,indexr-indexd);
        indexs:=StrMatch(data,1," ");
        dataok:=StrToVal(StrPart(data,1+3,indexs-1-1),cdat.i);
        indexs2:=StrMatch(data,indexs+1," ");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.tx);
        indexs:=StrMatch(data,indexs2+1," ");
        dataok:=StrToVal(StrPart(data,indexs2+1,indexs-indexs2-1),cdat.ty);
        indexs2:=StrMatch(data,indexs+1,"""");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.tz);
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Point data from SF: i=" + ValToStr(cdat.i) + " x=" + ValToStr(cdat.tx) + " y=" + ValToStr(cdat.ty) + " z=" + ValToStr(cdat.tz);
        ENDIF
    ENDIF
    
    !Part 2 (orientations)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><gca i=""" + ValToStr(4) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
 
    edat:=ASFM_HasError(stASFMReceived);
    IF edat.cerr = -1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get ASFM point data (part 2). Err= ", \Num:=edat.cerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Get SF Point Part 2 error on vision system! Err="+ValToStr(edat.cerr);
        ENDIF 
        RETURN cdat;
    ENDIF
    
    IF edat.cres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get ASFM point data (part 2). Err= ", \Num:=edat.cerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Get SF Point Part 2 error on vision system! Err="+ValToStr(edat.cerr);
        ENDIF 
        RETURN cdat;
    ELSE
        indexd:=StrMatch(stASFMReceived,1,"d=");
        indexr:=StrMatch(stASFMReceived,indexd,"r=");
        data:=StrPart(stASFMReceived,indexd,indexr-indexd);
        indexs:=StrMatch(data,1," ");
        indexs:=StrMatch(data,1," ");
        dataok:=StrToVal(StrPart(data,1+3,indexs-1-1),cdat.i);
        indexs2:=StrMatch(data,indexs+1," ");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.oa);
        indexs:=StrMatch(data,indexs2+1," ");
        dataok:=StrToVal(StrPart(data,indexs2+1,indexs-indexs2-1),cdat.ob);
        indexs2:=StrMatch(data,indexs+1,"""");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.oc);
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Point data from SF: i=" + ValToStr(cdat.i) + " a=" + ValToStr(cdat.oa) + " b=" + ValToStr(cdat.ob) + " c=" + ValToStr(cdat.oc);
        ENDIF
    ENDIF
    !Part 3 (geometric)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><gcg i=""" + ValToStr(1) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF
 
    edat:=ASFM_HasError(stASFMReceived);
    IF edat.cerr = -1 THEN
        TPWrite "Problem in retrieving error data!";
        RETURN cdat;
        !Stop;
    ENDIF
    
    IF edat.cres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get ASFM point data (part 3). Err= ", \Num:=edat.cerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Get SF Point Part 3 error on vision system! Err="+ValToStr(edat.cerr);
        ENDIF 
        RETURN cdat;
    ELSE
        indexd:=StrMatch(stASFMReceived,1,"d=");
        indexr:=StrMatch(stASFMReceived,indexd,"r=");
        data:=StrPart(stASFMReceived,indexd,indexr-indexd);
        indexs:=StrMatch(data,1," ");
        indexs:=StrMatch(data,1," ");
        dataok:=StrToVal(StrPart(data,1+3,indexs-1-1),cdat.i);
        indexs2:=StrMatch(data,indexs+1," ");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.gp);
        indexs:=StrMatch(data,indexs2+1," ");
        dataok:=StrToVal(StrPart(data,indexs2+1,indexs-indexs2-1),cdat.ms);
        indexs2:=StrMatch(data,indexs+1,"""");
        dataok:=StrToVal(StrPart(data,indexs+1,indexs2-indexs-1),cdat.ar);
        
        cdat.Status:=3;
        
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Point data from SF: i=" + ValToStr(cdat.i) + " ar=" + ValToStr(cdat.ar) + " gp=" + ValToStr(cdat.gp) + " ms=" + ValToStr(cdat.ms);
        ENDIF
    ENDIF
    RETURN cdat;
ENDFUNC

!Function to send the sca command (calibration related).
!IMPORTANT: Functions sends six commands: sc1 to sc6 to fulfill the 80 characters max length requirement
!Includes the management of the error status in the reply (separated for each part)
!ARGUMENTS:
!    rid = request ID (see AUTO-CAL manual for details)
!    sid = sequence ID (see AUTO-CAL manual for details)
!    d1 = first argument (format = +/-xxxx.xx)
!    d2 = second argument (format = +/-xxxx.xx)
!    d3 = third argument (format = +/-xxxx.xx)
!    d4 = fourth argument (format = +/-xxxx.xx)
!    d5 = fifth argument (format = +/-xxxx.xx)
!    d6 = sixth argument (format = +/-xxxx.xx)
FUNC bool ACAL_Command(num rid, num sid, num d1, num d2, num d3, num d4, num d5, num d6) 
    VAR string comstr;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num status;
    VAR num icorr;
    VAR bool dataok;
    VAR bool Fout;
    VAR robtarget p1;
    Fout := FALSE;
    
    !Uses the tool and wobj data defined in ASFM module by command ASFM_SetTool
    p1 := CRobT(\Tool:=MyToolASFM \WObj:=MyWobjASFM);
    
    !Send first part of command (sc1)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><sc1 rid=""" + ValToStr(rid) + """ sid=""" + ValToStr(sid) + """ x=""" + numToStr(d1,2) + """ y=""" + numToStr(d2,2) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    ASFM_WaitTimeMs 100;
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot send sca command (part 1). Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Calibration command error (part 1) on vision system! Err=" + ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ENDIF
    
    !Send second part of command (sc2)
    !comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><sc2 z=""" + numToStr(p1.trans.z,2) + """ a=""" + NumToStr(EulerZYX(\X,p1.rot),2) + """ /></com>";
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><sc2 z=""" + numToStr(d3,2) + """ a=""" + NumToStr(d4,2) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    ASFM_WaitTimeMs 100;
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot send sca command (part 2). Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Calibration command error (part 2) on vision system! Err=" + ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ENDIF
    
    !Send third part of command (sc3)
    !comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><sc3 b=""" + NumToStr(EulerZYX(\Y,p1.rot),2) + """ c=""" + NumToStr(EulerZYX(\Z,p1.rot),2) + """ /></com>";
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><sc3 b=""" + NumToStr(d5,2) + """ c=""" + NumToStr(d6,2) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    ASFM_WaitTimeMs 100;
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot send sca command (part 3). Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Calibration command error (part 3) on vision system! Err=" + ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ENDIF
    
    !Send fourth part of command (sc4)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><sc4 d1=""" + ValToStr(d1) + """ d2=""" + ValToStr(d2) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    ASFM_WaitTimeMs 100;
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot send sca command (part 4). Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Calibration command error (part 4) on vision system! Err=" + ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ENDIF
    
    !Send fifth part of command (sc5)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><sc5 d3=""" + ValToStr(d3) + """ d4=""" + ValToStr(d4) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    ASFM_WaitTimeMs 100;
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot send sca command (part 5). Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Calibration command error (part 5) on vision system! Err="+ ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ENDIF
    
    !Send sixth part of command (sc6)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><sc6 d5=""" + ValToStr(d5) + """ d6=""" + ValToStr(d6) + """ /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    ASFM_WaitTimeMs 100;
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=15000;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot send sca command (part 6). Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Calibration command error (part 6) on vision system! Err="+ ValToStr(comerr);
        ENDIF
        RETURN Fout;
    ENDIF
    Fout:=TRUE;
    RETURN Fout;
ENDFUNC

!Function to retrieve the calibration data from the AUTO-CAL module.
!IMPORTANT: Functions sends three commands: gc1, gc2 and gc3 since complete reply was longer than 80 characters...
!ARGUMENTS:
!    None
!OUTPUT:
!    CalOut contains the calibration data (CalOut.calxyzabc)
!Includes the management of the error status in the reply (separated for Part 1, Part 2 and Part 3)
FUNC caldata ACAL_GetData() 
    VAR caldata CalOut;
    VAR string comstr;
    VAR string data;
    VAR num indexd;
    VAR num indexr;
    VAR num indexe;
    VAR num indexs;
    VAR num indexok;
    VAR num comres;
    VAR num comerr;
    VAR num status;
    VAR num icorr;
    VAR bool dataok;
    CalOut.status:=-1;
    CalOut.calerrors.x := -1;
    CalOut.calerrors.y := -1;
    CalOut.calerrors.z := -1;
    
    !Send first part of command (gc1)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><gc1 /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    ASFM_WaitTimeMs 100;
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get calibration data (part 1). Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Calibration retrieve command error (part 1) on vision system! Err=" + ValToStr(comerr);
        ENDIF
        RETURN CalOut;
    ELSE
        indexd:=StrMatch(stASFMReceived,1,"d1=");
        indexr:=StrMatch(stASFMReceived,indexd,"d2=");
        indexe:=StrMatch(stASFMReceived,indexr,"/");
        data:=StrPart(stASFMReceived,indexd,indexe-indexd);
        dataok:=StrToVal(StrPart(stASFMReceived,indexd+4,indexr-indexd-6),CalOut.tx);
        dataok:=StrToVal(StrPart(stASFMReceived,indexr+4,indexe-indexr-5),CalOut.ty);
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Calibration data (part 1): X=" + ValToStr(CalOut.tx) + "Y=" + ValToStr(CalOut.ty);
        ENDIF
    ENDIF
    
    !Send second part of command (gc2)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><gc2 /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    ASFM_WaitTimeMs 100;
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get calibration data (part 2). Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Calibration retrieve command error (part 2) on vision system! Err=" + ValToStr(comerr);
        ENDIF
        RETURN CalOut;
    ELSE
        indexd:=StrMatch(stASFMReceived,1,"d3=");
        indexr:=StrMatch(stASFMReceived,indexd,"d4=");
        indexe:=StrMatch(stASFMReceived,indexr,"/");
        data:=StrPart(stASFMReceived,indexd,indexe-indexd);
        dataok:=StrToVal(StrPart(stASFMReceived,indexd+4,indexr-indexd-6),CalOut.tz);
        dataok:=StrToVal(StrPart(stASFMReceived,indexr+4,indexe-indexr-5),CalOut.oa);
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Calibration data (part 2): Z=" + ValToStr(CalOut.tz) + " A=" + ValToStr(CalOut.oa);
        ENDIF
    ENDIF
    
    !Send third part of command (gc3)
    comstr:="<com ts="""+ValToStr(ASFMSeqID)+"""><gc3 /></com>";
    SocketSend ComASFMSocket \Str:=comstr;
    ASFMSeqID:=ASFMSeqID+1;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Sent:" + comstr;
    ENDIF
    ASFM_WaitTimeMs 100;
    SocketReceive ComASFMSocket \Str:=stASFMReceived \Time:=500;
    IF ASFM_M_Lvl > 3 THEN
        TPWrite "Received:" + stASFMReceived;
    ENDIF 
    indexr:=StrMatch(stASFMReceived,1,"r=");
    indexe:=StrMatch(stASFMReceived,indexr,"e=");
    indexs:=StrMatch(stASFMReceived,indexr,"/");
    IF indexe > StrLen(stASFMReceived) THEN
        indexok:=indexs; 
        icorr:=4;
    ELSE
        indexok:=indexe;
        icorr:=5;
        dataok:=StrToVal(StrPart(stASFMReceived,indexe+3,indexs-indexe-4),comerr);
    ENDIF
    dataok:=StrToVal(StrPart(stASFMReceived,indexr+3,indexok-indexr-icorr),comres);
    IF comres=-1 THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: Cannot get calibration data (part 3). Err= ", \Num:=comerr;
        ENDIF
        IF ASFM_M_Lvl > 0 THEN
           TPWrite "Calibration retrieve command error (part 3) on vision system! Err=" + ValToStr(comerr);
        ENDIF
        RETURN CalOut;
    ELSE
        indexd:=StrMatch(stASFMReceived,1,"d5=");
        indexr:=StrMatch(stASFMReceived,indexd,"d6=");
        indexe:=StrMatch(stASFMReceived,indexr,"/");
        data:=StrPart(stASFMReceived,indexd,indexe-indexd);
        dataok:=StrToVal(StrPart(stASFMReceived,indexd+4,indexr-indexd-6),CalOut.ob);
        dataok:=StrToVal(StrPart(stASFMReceived,indexr+4,indexe-indexr-5),CalOut.oc);
        IF ASFM_M_Lvl > 2 THEN
           TPWrite "Calibration data (part 3): B=" + ValToStr(CalOut.ob) + "C=" + ValToStr(CalOut.oc);
        ENDIF
    ENDIF
    CalOut.status:=1;
    RETURN CalOut;
    
ENDFUNC

!User level procedure to initialize communication channel with proper settings (once per set of measurements)
!Use ASFMu_Clear to close channel after measurements are completed
!ARGUMENTS:
!    SFI_Addr: IP Address (ex.: "192.168.2.13")
!    SFI_MLevel: 0=No message; 1=Error only; 2=Add correction data; 3=Add intermediate messages; 4=All messages
!    SFI_Tool: the tool used when sending robot TCP data
!    SFI_Wobj: the base (Wobj) used when sending robot TCP data
FUNC bool ASFMu_Initialize(string SFI_Addr,num SFI_MLevel, bool EnableLogError, bool EnableLogData, bool UseFlangeCalib, tooldata SFTool, wobjdata SFwObj)
    ASFM_SetCommunication SFI_Addr, 6344;
    ASFM_SetMessagingLevel SFI_MLevel;
    ASFM_SetTool SFTool, SFwObj;
    !Test
    ASFM_SetRefTool SFTool, SFwObj;
    
    ASFM_Connect;
    gUseFlangeCalib:=UseFlangeCalib;
    IF NOT ASFM_SetCalibrationType() THEN
        RETURN FALSE;
    ENDIF
    IF NOT ASFMu_Acknowledge() THEN
        RETURN FALSE;
    ENDIF
    IF NOT ASFM_SetTagE() THEN
        RETURN FALSE;
    ENDIF
    IF NOT ASFMu_GetStatus(0) THEN
        RETURN FALSE;
    ENDIF
    IF ASFMLaserStatus=-1 THEN
        RETURN FALSE;
    ENDIF 
    IF ASFMLaserStatus=2 THEN
        !Laser is currently disabled
        IF NOT ASFMu_Enable(0) THEN
            RETURN FALSE;
        ENDIF
    ENDIF 
    IF ASFMLaserStatus=1 THEN
        !Laser is currently ON (unmuted)
        IF NOT ASFMu_LaserOff(0) THEN
            RETURN FALSE;
        ENDIF
    ENDIF
    IF EnableLogData THEN
        ASFM_LogData:=TRUE;
    ELSE
        ASFM_LogData:=FALSE;
    ENDIF
    
    IF EnableLogError THEN
        ASFM_LogErrors:=TRUE;
        Open "HOME:", \File:="LogASFMErrors.txt", LogASFMErrors, \Append;
    ELSE
        ASFM_LogErrors:=FALSE;
    ENDIF
    RETURN TRUE;
ENDFUNC

!User level procedure to cleanly close communication channel
!ARGUMENTS:
!    None
FUNC bool ASFMu_Clear()
    IF NOT ASFMu_LaserOff(0) THEN
        RETURN FALSE;
    ENDIF
    SocketClose ComASFMSocket;
    IF ASFM_M_Lvl > 2 THEN
        TPWrite "Connection closed with IP=" + ASFM_IP_Add + " on PORT=" + ValToStr(ASFM_IP_Port);
    ENDIF
    
    IF ASFM_LogErrors THEN
        Close LogASFMErrors;
    ENDIF
    
    RETURN TRUE;
ENDFUNC

!High level function to use SF in mode 0 (direct point acquisition).
!ARGUMENTS:
!    SFTaskID: define the task number to use to acquire measurement (use -1 to keep current task)
!    FLength: filter length in profiles to apply to measurment
!OUTPUT:
!    corrdata.tx / ty / tz = XYZ data of returned point 
!    corrdata.oa / ob / oc = ABC orientation data of returned point
!    corrdata.ar / gp / ms = Geometric data associated to measurement
FUNC corrdata  ASFMu_GetPoint(num SFTaskID, num FLength) 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetPoint. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    !IF NOT ASFMu_SelectTask(SFTaskID) THEN
    !    cdat_out.Status:=-2;
    !    IF ASFM_LogErrors THEN
    !       Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetPoint. Status= ", \Num:=cdat_out.Status;
    !    ENDIF
    !    RETURN cdat_out;
    !ENDIF
    
    IF NOT ASFM_BeginJointFinding(0, 1, 1, SFTaskID) THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetPoint. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetPoint. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetPoint. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_AcquireMeasure(FLength, 1) THEN
        cdat_out.Status:=-6;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetPoint. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-7;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetPoint. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    cdat_out:=ASFM_GetPointData();
    IF cdat_out.Status < 0 THEN
        cdat_out.Status:=-8;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetPoint. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ELSE
        cdat_out.status:=3; !3=Data computed
        IF ASFM_LogData THEN
            Open "HOME:", \File:="LogMode0.txt", LogMode0, \Append;
            Write LogMode0, CDate() + "; " + CTime() + "; " \Num:=cdat_out.tx \NoNewLine;
            Write LogMode0, "; " \Num:=cdat_out.ty \NoNewLine;
            Write LogMode0, "; " \Num:=cdat_out.tz \NoNewLine;
            Write LogMode0, "; " \Num:=cdat_out.oa \NoNewLine;
            Write LogMode0, "; " \Num:=cdat_out.ob \NoNewLine;
            Write LogMode0, "; " \Num:=cdat_out.oc \NoNewLine;
            Write LogMode0, "; " \Num:=cdat_out.ar \NoNewLine;
            Write LogMode0, "; " \Num:=cdat_out.gp \NoNewLine;
            Write LogMode0, "; " \Num:=cdat_out.ms \NoNewLine;
            Write LogMode0, "      ";
            Close LogMode0;
        ENDIF
        RETURN cdat_out;
    ENDIF
ENDFUNC

!High level function to use SF in mode 1 (one point offset).
!ARGUMENTS:
!    Mode: 0=reference acquisition; 1=offset computation from new measurement
!    Seq: sequence ID in which reference is stored (accepted values: 2-999)
!    SFTaskID: define the task number to use to acquire measurement
!    FLength: filter length in number of profiles to apply to measurment
!OUTPUT:
!    corrdata.tx / ty / tz = XYZ offset data 
!    corrdata.ar / gp / ms = Geometric data associated to acquired measurement
FUNC corrdata  ASFMu_GetPointOffset(num Mode, num Seq, num SFTaskID, num FLength) 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetPointOffset. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    !IF NOT ASFMu_SelectTask(SFTaskID) THEN
    !    cdat_out.Status:=-2;
    !    IF ASFM_LogErrors THEN
    !       Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetPointOffset. Status= ", \Num:=cdat_out.Status;
    !    ENDIF
    !    RETURN cdat_out;
    !ENDIF
    
    IF NOT ASFM_BeginJointFinding(1, Mode, Seq, SFTaskID) THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetPointOffset. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetPointOffset. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetPointOffset. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_AcquireMeasure(FLength, 1) THEN
        cdat_out.Status:=-6;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetPointOffset. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-7;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetPointOffset. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    !Retrieve offset data only in current measurement mode (Mode=1)
    IF Mode=1 THEN
        cdat_out:=ASFM_GetCorrData(1);
        IF cdat_out.Status < 0 THEN
            cdat_out.Status:=-8;
            IF ASFM_LogErrors THEN
               Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetPointOffset. Status= ", \Num:=cdat_out.Status;
            ENDIF
            RETURN cdat_out;
        ELSE
            cdat_out.Status:=3; !3=Correction computed
            IF ASFM_M_Lvl>1 THEN
                TPWrite "Offset(1P): X=" + ValToStr(cdat_out.tx) + " Y=" + ValToStr(cdat_out.ty) + " Z=" + ValToStr(cdat_out.tz);
            ENDIF
            IF ASFM_LogData THEN
                Open "HOME:", \File:="LogMode1.txt", LogMode1, \Append;
                Write LogMode1, CDate() + "; " + CTime() + "; " \Num:=cdat_out.tx \NoNewLine;
                Write LogMode1, "; " \Num:=cdat_out.ty \NoNewLine;
                Write LogMode1, "; " \Num:=cdat_out.tz \NoNewLine;
                Write LogMode1, "; " \Num:=cdat_out.oa \NoNewLine;
                Write LogMode1, "; " \Num:=cdat_out.ob \NoNewLine;
                Write LogMode1, "; " \Num:=cdat_out.oc \NoNewLine;
                Write LogMode1, "; " \Num:=cdat_out.ar \NoNewLine;
                Write LogMode1, "; " \Num:=cdat_out.gp \NoNewLine;
                Write LogMode1, "; " \Num:=cdat_out.ms \NoNewLine;
                Write LogMode1, "      ";
                Close LogMode1;
            ENDIF
            RETURN cdat_out;
        ENDIF
    ELSE
        cdat_out.status:=1; !1=Reference acquired
        RETURN cdat_out;    
    ENDIF
    
ENDFUNC

!High level function to use SF in mode 3 (two points offset).
!ARGUMENTS:
!    Mode: 0=reference acquisition; 1=offset computation from new measurement
!    Seq: sequence ID in which reference is stored (accepted values: 2-999)
!    SFTaskID: define the task number to use to acquire measurement (use -1 to keep current task)
!    FLength: filter length in number of profiles to apply to measurment
!OUTPUT:
!    No data for this function (apart from status)
FUNC corrdata  ASFMu_Get2PointsOff1(num Mode, num Seq, num SFTaskID, num FLength) 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_Get2PointsOff1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    !IF NOT ASFMu_SelectTask(SFTaskID) THEN
    !    cdat_out.Status:=-2;
    !    IF ASFM_LogErrors THEN
    !       Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_Get2PointsOff1. Status= ", \Num:=cdat_out.Status;
    !    ENDIF
    !    RETURN cdat_out;
    !ENDIF
    
    IF NOT ASFM_BeginJointFinding(3, Mode, Seq, SFTaskID) THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_Get2PointsOff1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_Get2PointsOff1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_Get2PointsOff1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_AcquireMeasure(FLength, 1) THEN
        cdat_out.Status:=-6;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_Get2PointsOff1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-7;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_Get2PointsOff1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
   IF Mode=1 THEN 
      cdat_out.status:=2; !2=Current acquired
      RETURN cdat_out;
   ELSE
      cdat_out.status:=1; !1=Reference acquired
      RETURN cdat_out;
   ENDIF
ENDFUNC

!High level function to use SF in mode 3 (two points offset).
!ARGUMENTS:
!    Mode: 0=reference acquisition; 1=offset computation from new measurement
!    Seq: sequence ID in which reference is stored (accepted values: 2-999)
!    SFTaskID: define the task number to use to acquire measurement (use -1 to keep current task)
!    FLength: filter length in number of profiles to apply to measurment
!If Mode = 0, this function acquires reference on second point
!If Mode = 1, this function acquires measurement on second point
!OUTPUT:
!    corrdata.tx / ty / tz = XYZ offset data for first point
!    corrdata.ar / gp / ms = Geometric data associated to first acquired measurement
FUNC corrdata  ASFMu_Get2PointsOff2_1(num Mode, num Seq, num SFTaskID, num FLength) 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_Get2PointsOff2_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_Get2PointsOff2_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_Get2PointsOff2_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_AcquireMeasure(FLength, 2) THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_Get2PointsOff2_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_Get2PointsOff2_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    !Retrieve offset data only in current measurement mode (Mode=1)
    IF Mode=1 THEN
        cdat_out:=ASFM_GetCorrData(1);
        IF cdat_out.Status < 0 THEN
            cdat_out.Status:=-7;
            IF ASFM_LogErrors THEN
               Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_Get2PointsOff2_1. Status= ", \Num:=cdat_out.Status;
            ENDIF
            RETURN cdat_out;
        ELSE
            cdat_out.Status:=3; !3=Correction computed
            IF ASFM_LogData THEN
                Open "HOME:", \File:="LogMode3.txt", LogMode3, \Append;
                Write LogMode3, CDate() + "; " + CTime() + "; P1; " \Num:=cdat_out.tx \NoNewLine;
                Write LogMode3, "; " \Num:=cdat_out.ty \NoNewLine;
                Write LogMode3, "; " \Num:=cdat_out.tz \NoNewLine;
                Write LogMode3, "; " \Num:=cdat_out.oa \NoNewLine;
                Write LogMode3, "; " \Num:=cdat_out.ob \NoNewLine;
                Write LogMode3, "; " \Num:=cdat_out.oc \NoNewLine;
                Write LogMode3, "; " \Num:=cdat_out.ar \NoNewLine;
                Write LogMode3, "; " \Num:=cdat_out.gp \NoNewLine;
                Write LogMode3, "; " \Num:=cdat_out.ms \NoNewLine;
                Write LogMode3, "      ";
                Close LogMode3;
            ENDIF
            IF ASFM_M_Lvl>1 THEN
                TPWrite "Offset(2P) 1: X=" + ValToStr(cdat_out.tx) + " Y=" + ValToStr(cdat_out.ty) + " Z=" + ValToStr(cdat_out.tz);
            ENDIF
            RETURN cdat_out;
        ENDIF
    ELSE
        cdat_out.status:=1; !1=Reference acquired
        RETURN cdat_out;    
    ENDIF    
    
ENDFUNC

!High level function to use SF in mode 3 (two points offset).
!ARGUMENTS:
!    Mode: 0=reference acquisition; 1=offset computation from new measurement
!    Seq: sequence ID in which reference is stored (accepted values: 2-999)
!    SFTaskID: define the task number to use to acquire measurement (use -1 to keep current task)
!    FLength: filter length in number of profiles to apply to measurment
!If Mode = 0, this function does nothing
!If Mode = 1, this function retrieves offset of second point
!OUTPUT:
!    corrdata.tx / ty / tz = XYZ offset data for second point
!    corrdata.ar / gp / ms = Geometric data associated to second acquired measurement
FUNC corrdata  ASFMu_Get2PointsOff2_2(num Mode,num Seq, num SFTaskID, num FLength) 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_Get2PointsOff2_2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    !Retrieve offset data only in current measurement mode (Mode=1)
    IF Mode=1 THEN
        cdat_out:=ASFM_GetCorrData(2);
        IF cdat_out.Status < 0 THEN
            cdat_out.Status:=-7;
            Write LogMode3, "      ";
            IF ASFM_LogErrors THEN
               Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_Get2PointsOff2_2. Status= ", \Num:=cdat_out.Status;
            ENDIF
            RETURN cdat_out;
        ELSE
            cdat_out.Status:=3; !3=Correction computed
            IF ASFM_LogData THEN
                Open "HOME:", \File:="LogMode3.txt", LogMode3, \Append;
                Write LogMode3, CDate() + "; " + CTime() + "; P2; " \Num:=cdat_out.tx \NoNewLine;
                Write LogMode3, " " \Num:=cdat_out.ty \NoNewLine;
                Write LogMode3, " " \Num:=cdat_out.tz \NoNewLine;
                Write LogMode3, " " \Num:=cdat_out.oa \NoNewLine;
                Write LogMode3, " " \Num:=cdat_out.ob \NoNewLine;
                Write LogMode3, " " \Num:=cdat_out.oc \NoNewLine;
                Write LogMode3, " " \Num:=cdat_out.ar \NoNewLine;
                Write LogMode3, " " \Num:=cdat_out.gp \NoNewLine;
                Write LogMode3, " " \Num:=cdat_out.ms \NoNewLine;
                Write LogMode3, "      ";
                Close LogMode3;
            ENDIF
            IF ASFM_M_Lvl>1 THEN
                TPWrite "Offset(2P) 2: X=" + ValToStr(cdat_out.tx) + " Y=" + ValToStr(cdat_out.ty) + " Z=" + ValToStr(cdat_out.tz);
            ENDIF
            RETURN cdat_out;
        ENDIF
    ELSE
        cdat_out.status:=-8; !No data to retrieve in Mode=0 (ref)
        RETURN cdat_out;    
    ENDIF
    
ENDFUNC

!High level function to use SF in mode 5 (Corner computation with 3 points and angle).
!TCP must be in measurement point P1 when calling this function
!ARGUMENTS:
!    SFTaskID: define the task number to use to acquire measurements on P1 (use -1 to keep current task)
!    FLength: filter length in profiles to apply to measurment
!    SFAngle: angle of the corner to measure in degrees
!OUTPUT:
!    No specific data returned (only status)
FUNC corrdata  ASFMu_GetCorner3P1(num SeqID, num SFTaskID, num FLength, num SFAngle) 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    !IF NOT ASFMu_SelectTask(SFTaskID) THEN
    !    cdat_out.Status:=-2;
    !    IF ASFM_LogErrors THEN
    !       Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1. Status= ", \Num:=cdat_out.Status;
    !    ENDIF
    !    RETURN cdat_out;
    !ENDIF
    
    IF NOT ASFM_BeginJointFinding(5, 1, SeqID, SFTaskID) THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    !Specify corner angle
    IF NOT ASFM_SetAngle(SFAngle) THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    !Specify segment length (not used in mode 5)
    IF NOT ASFM_SetDistance(0) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-6;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    ASFM_WaitTimeMs 500;
    
    !Point 1
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-7;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_AcquireMeasure(FLength, 1) THEN
        cdat_out.Status:=-8;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-9;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    cdat_out.status:=2; !2=Data acquired
    RETURN cdat_out;
ENDFUNC

!High level function to use SF in mode 9 (Corner computation with 3 points and angle + Distance).
!TCP must be in measurement point P1 when calling this function
!ARGUMENTS:
!    SFTaskID: define the task number to use to acquire measurements on P1 (use -1 to keep current task)
!    FLength: filter length in profiles to apply to measurment
!    SFAngle: angle of the corner to measure in degrees
!    Dist: distance along main segment in mm between corner and next point
!IMPORTANT: ASFMu_GetCorner3P2 and ASFMu_GetCorner3P3 (_1 to _3) are used for next steps
!           In mode SF9, ASFM_GerCorner3P3_2 will contain XYZ data of second point + geometric information of P2
!OUTPUT:
!    No specific data returned (only status)
FUNC corrdata  ASFMu_GetCorner3P1_D(num SeqID, num SFTaskID, num FLength, num SFAngle, num Dist) 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1_D. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    !IF NOT ASFMu_SelectTask(SFTaskID) THEN
    !    cdat_out.Status:=-2;
    !    IF ASFM_LogErrors THEN
    !       Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1_D. Status= ", \Num:=cdat_out.Status;
    !    ENDIF
    !    RETURN cdat_out;
    !ENDIF
    
    IF NOT ASFM_BeginJointFinding(9, 1, SeqID, SFTaskID) THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1_D. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    !Specify corner angle
    IF NOT ASFM_SetAngle(SFAngle) THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1_D. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    !Specify segment length (not used in mode 5)
    IF NOT ASFM_SetDistance(Dist) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1_D. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    !Point 1
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-6;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1_D. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-7;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1_D. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_AcquireMeasure(FLength, 1) THEN
        cdat_out.Status:=-8;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1_D. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-9;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P1_D. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    cdat_out.status:=2; !2=Data acquired
    RETURN cdat_out;
ENDFUNC

!High level function to use SF in mode 5 (Corner computation with 3 points and angle).
!TCP must be in measurement point P2 when calling this function
!ARGUMENTS:
!    SFTaskID: define the task number to use to acquire measurements on P2 (use -1 to keep current task)
!    FLength: filter length in profiles to apply to measurment
!OUTPUT:
!    No specific data returned (only status)
FUNC corrdata  ASFMu_GetCorner3P2(num SFTaskID, num FLength) 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFMu_SelectTask(SFTaskID) THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
   
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_AcquireMeasure(FLength, 2) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-6;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    cdat_out.status:=2; !2=Data acquired                   
    RETURN cdat_out;
ENDFUNC

!High level function to use SF in mode 5 (Corner computation with 3 points and angle).
!TCP must be in measurement point P3 when calling this function
!ARGUMENTS:
!    SFTaskID: define the task number to use to acquire measurements on P3 (use -1 to keep current task)
!    FLength: filter length in profiles to apply to measurment
!OUTPUT:
!    CorrData: object of type corrdata containing the corner data + geometric information of P1
FUNC corrdata  ASFMu_GetCorner3P3_1(num SFTaskID, num FLength) 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P3_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFMu_SelectTask(SFTaskID) THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P3_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
   
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P3_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P3_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    ASFM_WaitTimeMs 100;
    IF NOT ASFM_AcquireMeasure(FLength, 3) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P3_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-6;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P3_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
                       
    cdat_out:=ASFM_GetCorrData(1); !Index 1 = Corner data + geometric data of P1
    IF cdat_out.Status = -1 THEN
        cdat_out.Status:=-7;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P3_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ELSE
        IF ASFM_M_Lvl>1 THEN
            TPWrite "Corner(3P): X=" + ValToStr(cdat_out.tx) + " Y=" + ValToStr(cdat_out.ty) + " Z=" + ValToStr(cdat_out.tz);
        ENDIF
        cdat_out.Status:=3; !3=Data computed
        IF ASFM_LogData THEN
            Open "HOME:", \File:="LogMode5.txt", LogMode5, \Append;
            Write LogMode5, CDate() + "; " + CTime() + "; P1; " \Num:=cdat_out.tx \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.ty \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.tz \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.ar \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.gp \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.ms \NoNewLine;
            Write LogMode5, "      ";
            Close LogMode5;
        ENDIF
        RETURN cdat_out;
    ENDIF
ENDFUNC

!High level function to use SF in mode 5 (Corner computation with 3 points and angle).
!TCP must be in measurement point P3 when calling this function
!ARGUMENTS:
!    None
!OUTPUT:
!    CorrData: object of type corrdata containing:
!              The geometric information of P2
FUNC corrdata  ASFMu_GetCorner3P3_2() 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P3_2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    cdat_out:=ASFM_GetGeoData(2); !Index 2 = Geometric data of P2 (+XYZ data of second point in mode SF9)
    IF cdat_out.Status = -1 THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P3_2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ELSE
        cdat_out.Status:=3; !3=Data computed 
        IF ASFM_LogData THEN
            Open "HOME:", \File:="LogMode5.txt", LogMode5, \Append;
            Write LogMode5, CDate() + "; " + CTime() + "; P2; " \Num:=cdat_out.tx \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.ty \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.tz \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.ar \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.gp \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.ms \NoNewLine;
            Write LogMode5, "      ";
            Close LogMode5;
        ENDIF
        RETURN cdat_out;
    ENDIF
ENDFUNC

!High level function to use SF in mode 5 (Corner computation with 3 points and angle).
!TCP must be in measurement point P3 when calling this function
!ARGUMENTS:
!    None
!OUTPUT:
!    CorrData: object of type corrdata containing:
!              The second point XYZ data + geometric information of P2
FUNC corrdata  ASFMu_GetCorner3P3_2D() 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P3_2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    cdat_out:=ASFM_GetCorrData(2); !Index 2 = Geometric data of P2 (+XYZ data of second point in mode SF9)
    IF cdat_out.Status = -1 THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P3_2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ELSE
        cdat_out.Status:=3; !3=Data computed 
        IF ASFM_LogData THEN
            Open "HOME:", \File:="LogMode5.txt", LogMode5, \Append;
            Write LogMode5, CDate() + "; " + CTime() + "; P2; " \Num:=cdat_out.tx \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.ty \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.tz \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.ar \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.gp \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.ms \NoNewLine;
            Write LogMode5, "      ";
            Close LogMode5;
        ENDIF
        RETURN cdat_out;
    ENDIF
ENDFUNC

!High level function to use SF in mode 5 (Corner computation with 3 points and angle).
!TCP must be in measurement point P3 when calling this function
!ARGUMENTS:
!    None
!OUTPUT:
!    CorrData: object of type corrdata containing the geometric information of P3
FUNC corrdata  ASFMu_GetCorner3P3_3() 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P3_3. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    cdat_out:=ASFM_GetGeoData(3); !Index 3 = Geometric data of P3
    IF cdat_out.Status = -1 THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner3P3_3. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ELSE
        cdat_out.Status:=3; !3=Data computed
        IF ASFM_LogData THEN
            Open "HOME:", \File:="LogMode5.txt", LogMode5, \Append;
            Write LogMode5, CDate() + "; " + CTime() + "; P3; " \Num:=cdat_out.tx \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.ty \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.tz \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.ar \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.gp \NoNewLine;
            Write LogMode5, "; " \Num:=cdat_out.ms \NoNewLine;
            Write LogMode5, "      ";
            Close LogMode5;
        ENDIF
        RETURN cdat_out;
    ENDIF
ENDFUNC

!High level function to use SF in mode 4 (Corner computation with 4 points).
!TCP must be in measurement point P1 when calling this function
!ARGUMENTS:
!    SFTaskID: define the task number to use to acquire measurements on P1 (use -1 to keep current task)
!    FLength: filter length in profiles to apply to measurment
!    SFTolerance: angle of the corner to measure in degrees
FUNC corrdata  ASFMu_GetCorner4P1(num SeqID, num SFTaskID, num FLength, num SFTolerance) 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    !IF NOT ASFMu_SelectTask(SFTaskID) THEN
    !    cdat_out.Status:=-2;
    !    IF ASFM_LogErrors THEN
    !       Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1. Status= ", \Num:=cdat_out.Status;
    !    ENDIF
    !    RETURN cdat_out;
    !ENDIF
    
    IF NOT ASFM_BeginJointFinding(4, 1, SeqID, SFTaskID) THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    !Specify corner angle
    IF NOT ASFM_SetTolerance(SFTolerance) THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    !Specify segment length (not used in mode 4)
    IF NOT ASFM_SetDistance(0) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-6;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    !Point 1
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-7;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_AcquireMeasure(FLength, 1) THEN
        cdat_out.Status:=-8;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-9;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    cdat_out.status:=2; !1=Data acquired
    RETURN cdat_out;
ENDFUNC

!High level function to use SF in mode 6 (Corner computation with 4 points + Distance).
!TCP must be in measurement point P1 when calling this function
!ARGUMENTS:
!    SFTaskID: define the task number to use to acquire measurements on P1 (use -1 to keep current task)
!    FLength: filter length in profiles to apply to measurment
!    SFTolerance: tolerance in mm for corner computation (intersection of segments 1 and 2)
!    Dist: distance along main segment in mm between corner and next point
!IMPORTANT: ASFMu_GetCorner4P2,ASFMu_GetCorner4P3 and ASFMu_GetCorner4P4 (_1 to _4) are used for next steps
!           In mode SF6, ASFM_GetCorner4P4_2 will contain XYZ data of second point + geometric information of P2
FUNC corrdata  ASFMu_GetCorner4P1_D(num SeqID, num SFTaskID, num FLength, num SFTolerance, num Dist) 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1_D. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    !IF NOT ASFMu_SelectTask(SFTaskID) THEN
    !    cdat_out.Status:=-2;
    !    IF ASFM_LogErrors THEN
    !       Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1_D. Status= ", \Num:=cdat_out.Status;
    !    ENDIF
    !    RETURN cdat_out;
    !ENDIF
    
    IF NOT ASFM_BeginJointFinding(6, 1, SeqID, SFTaskID) THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1_D. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    !Specify corner angle
    IF NOT ASFM_SetTolerance(SFTolerance) THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1_D. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    !Specify segment length (not used in mode 5)
    IF NOT ASFM_SetDistance(Dist) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1_D. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    !Point 1
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-6;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1_D. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-7;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1_D. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_AcquireMeasure(FLength, 1) THEN
        cdat_out.Status:=-8;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1_D. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-9;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P1_D. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    cdat_out.status:=2; !1=Data acquired
    RETURN cdat_out;
ENDFUNC

!High level function to use SF in mode 4 (Corner computation with 4 points).
!TCP must be in measurement point P2 when calling this function
!ARGUMENTS:
!    SFTaskID: define the task number to use to acquire measurements on P2 (use -1 to keep current task)
!    FLength: filter length in profiles to apply to measurment
FUNC corrdata  ASFMu_GetCorner4P2(num SFTaskID, num FLength) 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFMu_SelectTask(SFTaskID) THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
   
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_AcquireMeasure(FLength, 2) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-6;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    cdat_out.status:=2; !1=Data acquired                
    RETURN cdat_out;
ENDFUNC

!High level function to use SF in mode 4 (Corner computation with 4 points).
!TCP must be in measurement point P3 when calling this function
!ARGUMENTS:
!    SFTaskID: define the task number to use to acquire measurements on P3 (use -1 to keep current task)
!    FLength: filter length in profiles to apply to measurment
FUNC corrdata  ASFMu_GetCorner4P3(num SFTaskID, num FLength) 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P3. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFMu_SelectTask(SFTaskID) THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P3. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
   
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P3. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P3. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_AcquireMeasure(FLength, 3) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P3. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-6;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P3. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    cdat_out.status:=2; !1=Data acquired               
    RETURN cdat_out;
ENDFUNC

!High level function to use SF in mode 4 (Corner computation with 4 points).
!TCP must be in measurement point P4 when calling this function
!ARGUMENTS:
!    SFTaskID: define the task number to use to acquire measurements on P4 (use -1 to keep current task)
!    FLength: filter length in profiles to apply to measurment
!OUTPUT:
!    CorrData: object of type corrdata containing the corner data + geometric information of P1
FUNC corrdata  ASFMu_GetCorner4P4_1(num SFTaskID, num FLength) 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P4_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFMu_SelectTask(SFTaskID) THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P4_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
   
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P4_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P4_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_AcquireMeasure(FLength, 4) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P4_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-6;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P4_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
                       
    cdat_out:=ASFM_GetCorrData(1); !Index 1 = Corner data + geometric data of P1
    IF cdat_out.Status = -1 THEN
        !TPWrite "Get data error for GetCorner4P";
        cdat_out.Status:=-7;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P4_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ELSE
        IF ASFM_M_Lvl>1 THEN
            TPWrite "Corner(4P)-P1: X=" + ValToStr(cdat_out.tx) + " Y=" + ValToStr(cdat_out.ty) + " Z=" + ValToStr(cdat_out.tz);
        ENDIF
        cdat_out.Status:=3; !3=Data computed
        IF ASFM_LogData THEN
            Open "HOME:", \File:="LogMode4.txt", LogMode4, \Append;
            Write LogMode4, CDate() + "; " + CTime() + "; P1; " \Num:=cdat_out.tx \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.ty \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.tz \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.ar \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.gp \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.ms \NoNewLine;
            Write LogMode4, "      ";
            Close LogMode4;
        ENDIF
        RETURN cdat_out;
    ENDIF
ENDFUNC

!High level function to use SF in mode 4 (Corner computation with 4 points).
!ARGUMENTS:
!    None
!OUTPUT:
!    CorrData: object of type corrdata containing:
!              The geometric information of P2
FUNC corrdata  ASFMu_GetCorner4P4_2() 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P4_2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    cdat_out:=ASFM_GetGeoData(2); !Index 3 = Geometric data of P3
    IF cdat_out.Status = -1 THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P4_2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ELSE
        IF ASFM_M_Lvl>1 THEN
            TPWrite "Corner(4P)-P2: X=" + ValToStr(cdat_out.tx) + " Y=" + ValToStr(cdat_out.ty) + " Z=" + ValToStr(cdat_out.tz);
        ENDIF
        cdat_out.Status:=3; !3=Data computed
        IF ASFM_LogData THEN
            Open "HOME:", \File:="LogMode4.txt", LogMode4, \Append;
            Write LogMode4, CDate() + "; " + CTime() + "; P2; " \Num:=cdat_out.tx \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.ty \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.tz \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.ar \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.gp \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.ms \NoNewLine;
            Write LogMode4, "      ";
            Close LogMode4;
        ENDIF
        RETURN cdat_out;
    ENDIF
ENDFUNC

!High level function to use SF in mode 4 (Corner computation with 4 points).
!ARGUMENTS:
!    None
!OUTPUT:
!    CorrData: object of type corrdata containing:
!              The second point XYZ data + geometric information of P2
FUNC corrdata  ASFMu_GetCorner4P4_2D() 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P4_2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    cdat_out:=ASFM_GetCorrData(2); !Index 3 = Geometric data of P3
    IF cdat_out.Status = -1 THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P4_2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ELSE
        IF ASFM_M_Lvl>1 THEN
            TPWrite "Corner(4P)-P2: X=" + ValToStr(cdat_out.tx) + " Y=" + ValToStr(cdat_out.ty) + " Z=" + ValToStr(cdat_out.tz);
        ENDIF
        cdat_out.Status:=3; !3=Data computed
        IF ASFM_LogData THEN
            Open "HOME:", \File:="LogMode4.txt", LogMode4, \Append;
            Write LogMode4, CDate() + "; " + CTime() + "; P2; " \Num:=cdat_out.tx \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.ty \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.tz \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.ar \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.gp \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.ms \NoNewLine;
            Write LogMode4, "      ";
            Close LogMode4;
        ENDIF
        RETURN cdat_out;
    ENDIF
ENDFUNC

!High level function to use SF in mode 4 (Corner computation with 4 points).
!ARGUMENTS:
!    None
!OUTPUT:
!    CorrData: object of type corrdata containing the geometric information of P3
FUNC corrdata  ASFMu_GetCorner4P4_3() 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P4_3. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    cdat_out:=ASFM_GetGeoData(3); !Index 3 = Geometric data of P3
    IF cdat_out.Status = -1 THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P4_3. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ELSE
        cdat_out.Status:=3; !3=Data computed
        IF ASFM_LogData THEN
            Open "HOME:", \File:="LogMode4.txt", LogMode4, \Append;
            Write LogMode4, CDate() + "; " + CTime() + "; P3; " \Num:=cdat_out.tx \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.ty \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.tz \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.ar \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.gp \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.ms \NoNewLine;
            Write LogMode4, "      ";
            Close LogMode4;
        ENDIF
        RETURN cdat_out;
    ENDIF
ENDFUNC

!High level function to use SF in mode 4 (Corner computation with 4 points).
!ARGUMENTS:
!    None
!OUTPUT:
!    CorrData: object of type corrdata containing the geometric information of P4
FUNC corrdata  ASFMu_GetCorner4P4_4() 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P4_4. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    cdat_out:=ASFM_GetGeoData(4); !Index 3 = Geometric data of P3
    IF cdat_out.Status = -1 THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCorner4P4_4. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ELSE
        cdat_out.Status:=3; !3=Data computed
        IF ASFM_LogData THEN
            Open "HOME:", \File:="LogMode4.txt", LogMode4, \Append;
            Write LogMode4, CDate() + "; " + CTime() + "; P4; " \Num:=cdat_out.tx \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.ty \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.tz \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.ar \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.gp \NoNewLine;
            Write LogMode4, " " \Num:=cdat_out.ms \NoNewLine;
            Write LogMode4, "      ";
            Close LogMode4;
        ENDIF
        RETURN cdat_out;
    ENDIF
ENDFUNC

!High level function to use SF in mode 8 (Circle computation with 3 points).
!TCP must be in measurement point P1 when calling this function
!ARGUMENTS:
!    SFTaskID: define the task number to use to acquire measurements on P1 (use -1 to keep current task)
!    FLength: filter length in profiles to apply to measurment
!    SFAngle: angle of the corner to measure in degrees
FUNC corrdata  ASFMu_GetCircleP1(num SeqID, num SFTaskID, num FLength) 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    !IF NOT ASFMu_SelectTask(SFTaskID) THEN
    !    cdat_out.Status:=-2;
    !    IF ASFM_LogErrors THEN
    !       Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P3_1. Status= ", \Num:=cdat_out.Status;
    !    ENDIF
    !    RETURN cdat_out;
    !ENDIF
    
    IF NOT ASFM_BeginJointFinding(8, 1, SeqID, SFTaskID) THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    !Point 1
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_AcquireMeasure(FLength, 1) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-6;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    cdat_out.status:=2; !1=Data acquired
    RETURN cdat_out;
ENDFUNC

!High level function to use SF in mode 8 (Circle computation with 3 points).
!TCP must be in measurement point P2 when calling this function
!ARGUMENTS:
!    SFTaskID: define the task number to use to acquire measurements on P2 (use -1 to keep current task)
!    FLength: filter length in profiles to apply to measurment
FUNC corrdata  ASFMu_GetCircleP2(num SFTaskID, num FLength) 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFMu_SelectTask(SFTaskID) THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
   
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_AcquireMeasure(FLength, 2) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-6;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    cdat_out.status:=2; !1=Data acquired              
    RETURN cdat_out;
ENDFUNC

!High level function to use SF in mode 8 (Circle computation with 3 points).
!TCP must be in measurement point P3 when calling this function
!ARGUMENTS:
!    SFTaskID: define the task number to use to acquire measurements on P3 (use -1 to keep current task)
!    FLength: filter length in profiles to apply to measurment
!OUTPUT:
!    CorrData: object of type corrdata containing the corner data + geometric information of P1
FUNC corrdata  ASFMu_GetCircleP3_1(num SFTaskID, num FLength) 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P3_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFMu_SelectTask(SFTaskID) THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P3_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
   
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P3_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P3_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_AcquireMeasure(FLength, 3) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P3_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-6;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P3_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
                       
    cdat_out:=ASFM_GetCorrData(1); !Index 1 = Circle center data + geometric data of P1
    IF cdat_out.Status = -1 THEN
        cdat_out.Status:=-7;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P3_1. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ELSE
        IF ASFM_M_Lvl>1 THEN
            TPWrite "Circle(center): X=" + ValToStr(cdat_out.tx) + " Y=" + ValToStr(cdat_out.ty) + " Z=" + ValToStr(cdat_out.tz);
        ENDIF
        cdat_out.Status:=3; !3=Data computed
        IF ASFM_LogData THEN
            Open "HOME:", \File:="LogMode8.txt", LogMode8, \Append;
            Write LogMode8, CDate() + "; " + CTime() + "; P1; " \Num:=cdat_out.tx \NoNewLine;
            Write LogMode8, "; " \Num:=cdat_out.ty \NoNewLine;
            Write LogMode8, "; " \Num:=cdat_out.tz \NoNewLine;
            Write LogMode8, "; " \Num:=cdat_out.ar \NoNewLine;
            Write LogMode8, "; " \Num:=cdat_out.gp \NoNewLine;
            Write LogMode8, "; " \Num:=cdat_out.ms \NoNewLine;
            Write LogMode8, "      ";
            Close LogMode8;
        ENDIF
        RETURN cdat_out;
    ENDIF
ENDFUNC

!High level function to use SF in mode 8 (Circle computation with 3 points).
!TCP must be in measurement point P3 when calling this function
!ARGUMENTS:
!    None
!OUTPUT:
!    CorrData: object of type corrdata containing:
!              In mode SF5: the geometric information of P2
!              In mode SF9: the second point XYZ data + geometric information of P2
FUNC corrdata  ASFMu_GetCircleP3_2() 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P3_2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    cdat_out:=ASFM_GetCorrData(2); !Index 2 = Circle radius + geometric data of P2
    IF cdat_out.Status = -1 THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P3_2. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ELSE
        IF ASFM_M_Lvl>1 THEN
            TPWrite "Circle(diameter): D=" + ValToStr(cdat_out.tx);
        ENDIF
        cdat_out.Status:=3; !3=Data computed
        IF ASFM_LogData THEN
            Open "HOME:", \File:="LogMode8.txt", LogMode8, \Append;
            Write LogMode8, CDate() + "; " + CTime() + "; P2; " \Num:=cdat_out.tx \NoNewLine;
            Write LogMode8, "; " \Num:=cdat_out.ty \NoNewLine;
            Write LogMode8, "; " \Num:=cdat_out.tz \NoNewLine;
            Write LogMode8, "; " \Num:=cdat_out.ar \NoNewLine;
            Write LogMode8, "; " \Num:=cdat_out.gp \NoNewLine;
            Write LogMode8, "; " \Num:=cdat_out.ms \NoNewLine;
            Write LogMode8, "      ";
            Close LogMode8;
        ENDIF
        RETURN cdat_out;
    ENDIF
ENDFUNC

!High level function to use SF in mode 8 (Circle computation with 3 points).
!TCP must be in measurement point P3 when calling this function
!ARGUMENTS:
!    None
!OUTPUT:
!    CorrData: object of type corrdata containing the geometric information of P3
FUNC corrdata  ASFMu_GetCircleP3_3() 
    VAR corrdata cdat_out;
    cdat_out.Status:=-1;
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P3_3. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    cdat_out:=ASFM_GetCorrData(3); !Index 3 = Geometric data of P3
    IF cdat_out.Status = -1 THEN
        cdat_out.Status:=-2;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetCircle3P3_3. Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ELSE
        cdat_out.Status:=3; !3=Data computed
        IF ASFM_LogData THEN
            Open "HOME:", \File:="LogMode8.txt", LogMode8, \Append;
            Write LogMode8, CDate() + "; " + CTime() + "; P3; " \Num:=cdat_out.tx \NoNewLine;
            Write LogMode8, "; " \Num:=cdat_out.ty \NoNewLine;
            Write LogMode8, "; " \Num:=cdat_out.tz \NoNewLine;
            Write LogMode8, "; " \Num:=cdat_out.ar \NoNewLine;
            Write LogMode8, "; " \Num:=cdat_out.gp \NoNewLine;
            Write LogMode8, "; " \Num:=cdat_out.ms \NoNewLine;
            Write LogMode8, "      ";
            Close LogMode8;
        ENDIF
        RETURN cdat_out;
    ENDIF
ENDFUNC

!High level function to use SF in mode 11 (direct hole acquisition with dual "X" laser).
!ARGUMENTS:
!    SFTaskID: define the task number to use to acquire measurement (use -1 to keep current task)
!    FLength: filter length in profiles to apply to measurment
!OUTPUT:
!    corrdata.tx / ty / tz = XYZ data of hole center 
!    corrdata.oa / ob / oc = AB (C=0) orientation data of hole
!    corrdata.ar / gp / ms = Empty
!    corrdata.tx2 / ty2 / tz2 = XYZ data of normal vector
!    corrdata.tx3 = Radius of the hole in mm

FUNC corrdata3  ASFMu_GetHoleX(num SFTaskID, num FLength) 
    VAR corrdata3 cdat_out;
    VAR corrdata cdat_temp;
    cdat_out.Status:=-1;
    cdat_out.Status2:=-1;
    cdat_out.Status3:=-1;
    
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetHoleX.Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    !IF NOT ASFMu_SelectTask(SFTaskID) THEN
    !    cdat_out.Status:=-2;
    !    IF ASFM_LogErrors THEN
    !       Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetHoleX. Status= ", \Num:=cdat_out.Status;
    !    ENDIF
    !    RETURN cdat_out;
    !ENDIF
    
    IF NOT ASFM_BeginJointFinding(11, 1, 1, SFTaskID) THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetHoleX.Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetHoleX.Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetHoleX.Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_AcquireMeasure(FLength, 1) THEN
        cdat_out.Status:=-6;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetHoleX.Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-7;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetHoleX.Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    cdat_temp:=ASFM_GetCorrDataNoGeo(1); !Contains center point
    IF cdat_temp.Status < 0 THEN
        cdat_out.Status:=-8;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetHoleX.Status1= ", \Num:=cdat_temp.Status;
        ENDIF
        !cdat_out.Status:=cdat_temp.Status;
        TPWrite "Status1:bad";
        RETURN cdat_out;
    ELSE
        cdat_out.Status:=3; !3=Data computed
        cdat_out.tx:=cdat_temp.tx;
        cdat_out.ty:=cdat_temp.ty;
        cdat_out.tz:=cdat_temp.tz;
        cdat_out.oa:=cdat_temp.oa;
        cdat_out.ob:=cdat_temp.ob;
        cdat_out.oc:=cdat_temp.oc;
        
        cdat_temp:=ASFM_GetCorrDataNoOriNoGeo(2); !Contains normal vector in XYZ
        IF cdat_temp.Status < 0 THEN
            cdat_out.Status:=-8;
            cdat_out.Status2:=-7;
            IF ASFM_LogErrors THEN
                Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetHoleX.Status2= ", \Num:=cdat_temp.Status;
            ENDIF
            !cdat_out.Status2:=cdat_temp.Status;
            TPWrite "Status2:bad";
            RETURN cdat_out;
        ELSE
            cdat_out.Status2:=3; !3=Data computed
            cdat_out.tx2:=cdat_temp.tx;
            cdat_out.ty2:=cdat_temp.ty;
            cdat_out.tz2:=cdat_temp.tz;
            cdat_out.oa2:=-1;
            cdat_out.ob2:=-1;
            cdat_out.oc2:=-1;
            
            cdat_temp:=ASFM_GetCorrDataNoOriNoGeo(3); !Contains radius in X
            IF cdat_temp.Status < 0 THEN
                cdat_out.Status:=-9;
                cdat_out.Status3:=-7;
                IF ASFM_LogErrors THEN
                    Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetHoleX.Status3= ", \Num:=cdat_temp.Status;
                ENDIF
                !cdat_out.Status3:=cdat_temp.Status;
                TPWrite "Status3:bad";
                RETURN cdat_out;
            ELSE
                cdat_out.Status3:=3; !3=Data computed
                cdat_out.tx3:=cdat_temp.tx;
                cdat_out.ty3:=cdat_temp.ty;
                cdat_out.tz3:=cdat_temp.tz;
                cdat_out.oa3:=-1;
                cdat_out.ob3:=-1;
                cdat_out.oc3:=-1;
                
                IF ASFM_LogData THEN
                    Open "HOME:", \File:="LogMode11.txt", LogMode11, \Append;
                    Write LogMode11, CDate() + "; " + CTime() + "; " \Num:=cdat_out.tx \NoNewLine;
                    Write LogMode11, "; " \Num:=cdat_out.ty \NoNewLine;
                    Write LogMode11, "; " \Num:=cdat_out.tz \NoNewLine;
                    Write LogMode11, "; " \Num:=cdat_out.oa \NoNewLine;
                    Write LogMode11, "; " \Num:=cdat_out.ob \NoNewLine;
                    Write LogMode11, "; " \Num:=cdat_out.oc \NoNewLine;
                    Write LogMode11, "; " \Num:=cdat_out.tx2 \NoNewLine;
                    Write LogMode11, "; " \Num:=cdat_out.ty2 \NoNewLine;
                    Write LogMode11, "; " \Num:=cdat_out.tz2 \NoNewLine;
                    Write LogMode11, "; " \Num:=cdat_out.tx3 \NoNewLine;
                    Write LogMode11, "      ";
                    Close LogMode11;
                ENDIF
        
                RETURN cdat_out;
            ENDIF
        ENDIF
    ENDIF
ENDFUNC

!High level function to use SF in mode 12 (direct square hole acquisition with dual "X" laser).
!ARGUMENTS:
!    SFTaskID: define the task number to use to acquire measurement (use -1 to keep current task)
!    FLength: filter length in profiles to apply to measurment
!OUTPUT:
!    corrdata.tx / ty / tz = XYZ data of hole center 
!    corrdata.oa / ob / oc = AB (C=0) orientation data of hole
!    corrdata.ar / gp / ms = Empty
!    corrdata.tx2 / ty2 / tz2 = XYZ data of normal vector
!    corrdata.tx3 = Radius of the hole in mm

FUNC corrdata3  ASFMu_GetSquareHoleX(num SFTaskID, num FLength) 
    VAR corrdata3 cdat_out;
    VAR corrdata cdat_temp;
    cdat_out.Status:=-1;
    cdat_out.Status2:=-1;
    cdat_out.Status3:=-1;
    
    IF NOT ASFMu_Acknowledge() THEN
        cdat_out.Status:=-1;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetSquareHoleX.Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    
    !IF NOT ASFMu_SelectTask(SFTaskID) THEN
    !    cdat_out.Status:=-2;
    !    IF ASFM_LogErrors THEN
    !       Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetSquareHoleX. Status= ", \Num:=cdat_out.Status;
    !    ENDIF
    !    RETURN cdat_out;
    !ENDIF
    
    IF NOT ASFM_BeginJointFinding(12, 1, 1, SFTaskID) THEN
        cdat_out.Status:=-3;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetSquareHoleX.Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_SendTCPData() THEN
        cdat_out.Status:=-4;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetSquareHoleX.Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOn(0) THEN
        cdat_out.Status:=-5;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetSquareHoleX.Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFM_AcquireMeasure(FLength, 1) THEN
        cdat_out.Status:=-6;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetSquareHoleX.Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    IF NOT ASFMu_LaserOff(0) THEN
        cdat_out.Status:=-7;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetSquareHoleX.Status= ", \Num:=cdat_out.Status;
        ENDIF
        RETURN cdat_out;
    ENDIF
    cdat_temp:=ASFM_GetCorrDataNoGeo(1); !Contains center point
    IF cdat_temp.Status < 0 THEN
        cdat_temp.Status:=-8;
        IF ASFM_LogErrors THEN
           Write LogASFMErrors, CDate() + "; " +CTime() + "; Error: ASFMu_GetSquareHoleX.Status1= ", \Num:=cdat_temp.Status;
        ENDIF
        cdat_out.Status:=cdat_temp.Status;
        RETURN cdat_out;
    ELSE
        cdat_out.Status:=3; !3=Data computed
        cdat_out.tx:=cdat_temp.tx;
        cdat_out.ty:=cdat_temp.ty;
        cdat_out.tz:=cdat_temp.tz;
        cdat_out.oa:=cdat_temp.oa;
        cdat_out.ob:=cdat_temp.ob;
        cdat_out.oc:=cdat_temp.oc;
        
        IF ASFM_LogData THEN
            Open "HOME:", \File:="LogMode12.txt", LogMode12, \Append;
            Write LogMode12, CDate() + "; " + CTime() + "; " \Num:=cdat_out.tx \NoNewLine;
            Write LogMode12, "; " \Num:=cdat_out.ty \NoNewLine;
            Write LogMode12, "; " \Num:=cdat_out.tz \NoNewLine;
            Write LogMode12, "; " \Num:=cdat_out.oa \NoNewLine;
            Write LogMode12, "; " \Num:=cdat_out.ob \NoNewLine;
            Write LogMode12, "; " \Num:=cdat_out.oc \NoNewLine;
            Write LogMode12, "      ";
            Close LogMode12;
        ENDIF
        
        RETURN cdat_out;
    ENDIF
ENDFUNC

!Function to convert the acquired vision data (optical frame) into a robot position
!The function extracts the current robot flange position based on the set base in ASFM
!TCam transformation comes from the ASFMu_CalibrateFlange() function in ASFM module
FUNC robtarget ASFMu_TPtoBASE (caldata TP)
    VAR robtarget Out;
    VAR robtarget FPos;
    VAR pose FlangePose;
    VAR pos TPPos;
    FPos:= CRobT(\Tool:= NullToolASFM, \WObj:= MyWobjASFM);
    Out:=FPos;
    FlangePose.trans:=Fpos.trans;
    FlangePose.rot:=Fpos.rot;
    TPPos.x:=TP.tx;
    TPPos.y:=TP.ty;
    TPPos.z:=TP.tz;
    Out.trans:=PoseVect(FlangePose,PoseVect(TCam,TPPos));
    RETURN Out;
ENDFUNC

!This internal function is used to offset a robtarget variable in XYZ (translations) and ABC (Euler angles)
!p1       = position to offset (robtarget data type)
!dX,dY,dZ = translation in mm on corresponding axis
!dA,dB,dC = rotation around X, Y, Z axes
!Output: offset position (robtarget data type)
FUNC robtarget ASFM_ModPos (robtarget p1,num dX,num dY, num dZ, num da, num db, num dc)
    VAR robtarget Out;
    VAR num ax1;
    VAR num ay1;
    VAR num az1;
    ax1 := EulerZYX(\X,p1.rot);
    ay1 := EulerZYX(\Y,p1.rot);
    az1 := EulerZYX(\Z,p1.rot);
    Out:=p1;
    Out.rot := OrientZYX(az1+dc,ay1+db,ax1+da);
    
    Out.trans.x := p1.trans.x + dX;
    Out.trans.y := p1.trans.y + dY;
    Out.trans.z := p1.trans.z + dZ;
    WaitTime 0.1;
    
    RETURN Out;
ENDFUNC

ENDMODULE